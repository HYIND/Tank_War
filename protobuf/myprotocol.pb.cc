// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: myprotocol.proto

#include "myprotocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Message {
PROTOBUF_CONSTEXPR Hall_info_Response_User::Hall_info_Response_User(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Hall_info_Response_UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Hall_info_Response_UserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Hall_info_Response_UserDefaultTypeInternal() {}
  union {
    Hall_info_Response_User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Hall_info_Response_UserDefaultTypeInternal _Hall_info_Response_User_default_instance_;
PROTOBUF_CONSTEXPR Hall_info_Response_Roominfo::Hall_info_Response_Roominfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.host_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.room_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Hall_info_Response_RoominfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Hall_info_Response_RoominfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Hall_info_Response_RoominfoDefaultTypeInternal() {}
  union {
    Hall_info_Response_Roominfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Hall_info_Response_RoominfoDefaultTypeInternal _Hall_info_Response_Roominfo_default_instance_;
PROTOBUF_CONSTEXPR Hall_info_Response::Hall_info_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.userinfo_)*/{}
  , /*decltype(_impl_.roominfo_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Hall_info_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Hall_info_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Hall_info_ResponseDefaultTypeInternal() {}
  union {
    Hall_info_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Hall_info_ResponseDefaultTypeInternal _Hall_info_Response_default_instance_;
PROTOBUF_CONSTEXPR Hall_Message_Request::Hall_Message_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.content_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Hall_Message_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Hall_Message_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Hall_Message_RequestDefaultTypeInternal() {}
  union {
    Hall_Message_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Hall_Message_RequestDefaultTypeInternal _Hall_Message_Request_default_instance_;
PROTOBUF_CONSTEXPR Hall_Message_Response::Hall_Message_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.content_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Hall_Message_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Hall_Message_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Hall_Message_ResponseDefaultTypeInternal() {}
  union {
    Hall_Message_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Hall_Message_ResponseDefaultTypeInternal _Hall_Message_Response_default_instance_;
PROTOBUF_CONSTEXPR Hall_EnterRoom_Request::Hall_EnterRoom_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.room_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Hall_EnterRoom_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Hall_EnterRoom_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Hall_EnterRoom_RequestDefaultTypeInternal() {}
  union {
    Hall_EnterRoom_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Hall_EnterRoom_RequestDefaultTypeInternal _Hall_EnterRoom_Request_default_instance_;
PROTOBUF_CONSTEXPR Hall_EnterRoom_Response::Hall_EnterRoom_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.room_id_)*/0
  , /*decltype(_impl_.result_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Hall_EnterRoom_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Hall_EnterRoom_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Hall_EnterRoom_ResponseDefaultTypeInternal() {}
  union {
    Hall_EnterRoom_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Hall_EnterRoom_ResponseDefaultTypeInternal _Hall_EnterRoom_Response_default_instance_;
PROTOBUF_CONSTEXPR Ping_info::Ping_info(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ping_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Ping_infoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ping_infoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ping_infoDefaultTypeInternal() {}
  union {
    Ping_info _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ping_infoDefaultTypeInternal _Ping_info_default_instance_;
PROTOBUF_CONSTEXPR Set_User_id::Set_User_id(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Set_User_idDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Set_User_idDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Set_User_idDefaultTypeInternal() {}
  union {
    Set_User_id _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Set_User_idDefaultTypeInternal _Set_User_id_default_instance_;
PROTOBUF_CONSTEXPR Room_info_Response_User::Room_info_Response_User(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Room_info_Response_UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Room_info_Response_UserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Room_info_Response_UserDefaultTypeInternal() {}
  union {
    Room_info_Response_User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Room_info_Response_UserDefaultTypeInternal _Room_info_Response_User_default_instance_;
PROTOBUF_CONSTEXPR Room_info_Response::Room_info_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.userinfo_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Room_info_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Room_info_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Room_info_ResponseDefaultTypeInternal() {}
  union {
    Room_info_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Room_info_ResponseDefaultTypeInternal _Room_info_Response_default_instance_;
PROTOBUF_CONSTEXPR Room_Message_Request::Room_Message_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.content_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Room_Message_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Room_Message_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Room_Message_RequestDefaultTypeInternal() {}
  union {
    Room_Message_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Room_Message_RequestDefaultTypeInternal _Room_Message_Request_default_instance_;
PROTOBUF_CONSTEXPR Room_Message_Response::Room_Message_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.content_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Room_Message_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Room_Message_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Room_Message_ResponseDefaultTypeInternal() {}
  union {
    Room_Message_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Room_Message_ResponseDefaultTypeInternal _Room_Message_Response_default_instance_;
PROTOBUF_CONSTEXPR Room_Set_tankid::Room_Set_tankid(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Room_Set_tankidDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Room_Set_tankidDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Room_Set_tankidDefaultTypeInternal() {}
  union {
    Room_Set_tankid _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Room_Set_tankidDefaultTypeInternal _Room_Set_tankid_default_instance_;
PROTOBUF_CONSTEXPR Room_Set_tankid_Response::Room_Set_tankid_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Room_Set_tankid_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Room_Set_tankid_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Room_Set_tankid_ResponseDefaultTypeInternal() {}
  union {
    Room_Set_tankid_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Room_Set_tankid_ResponseDefaultTypeInternal _Room_Set_tankid_Response_default_instance_;
PROTOBUF_CONSTEXPR Room_Start_Response::Room_Start_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.result_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Room_Start_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Room_Start_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Room_Start_ResponseDefaultTypeInternal() {}
  union {
    Room_Start_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Room_Start_ResponseDefaultTypeInternal _Room_Start_Response_default_instance_;
PROTOBUF_CONSTEXPR Game_tankinfo_Request::Game_tankinfo_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.locationx_)*/0
  , /*decltype(_impl_.locationy_)*/0
  , /*decltype(_impl_.rotate_)*/0
  , /*decltype(_impl_.tank_style_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_tankinfo_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_tankinfo_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_tankinfo_RequestDefaultTypeInternal() {}
  union {
    Game_tankinfo_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_tankinfo_RequestDefaultTypeInternal _Game_tankinfo_Request_default_instance_;
PROTOBUF_CONSTEXPR Game_tankinfo_Response_tankinfo::Game_tankinfo_Response_tankinfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tankinfo_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.health_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_tankinfo_Response_tankinfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_tankinfo_Response_tankinfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_tankinfo_Response_tankinfoDefaultTypeInternal() {}
  union {
    Game_tankinfo_Response_tankinfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_tankinfo_Response_tankinfoDefaultTypeInternal _Game_tankinfo_Response_tankinfo_default_instance_;
PROTOBUF_CONSTEXPR Game_tankinfo_Response::Game_tankinfo_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_tankinfo_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_tankinfo_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_tankinfo_ResponseDefaultTypeInternal() {}
  union {
    Game_tankinfo_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_tankinfo_ResponseDefaultTypeInternal _Game_tankinfo_Response_default_instance_;
PROTOBUF_CONSTEXPR bulletinfo::bulletinfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.locationx_)*/0
  , /*decltype(_impl_.locationy_)*/0
  , /*decltype(_impl_.rotate_)*/0
  , /*decltype(_impl_.bullet_style_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct bulletinfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR bulletinfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~bulletinfoDefaultTypeInternal() {}
  union {
    bulletinfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 bulletinfoDefaultTypeInternal _bulletinfo_default_instance_;
PROTOBUF_CONSTEXPR Game_bulletinfo_Request::Game_bulletinfo_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bulletinfo_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_bulletinfo_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_bulletinfo_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_bulletinfo_RequestDefaultTypeInternal() {}
  union {
    Game_bulletinfo_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_bulletinfo_RequestDefaultTypeInternal _Game_bulletinfo_Request_default_instance_;
PROTOBUF_CONSTEXPR Game_bulletinfo_Response_Info::Game_bulletinfo_Response_Info(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bulletinfo_)*/{}
  , /*decltype(_impl_.tankid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_bulletinfo_Response_InfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_bulletinfo_Response_InfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_bulletinfo_Response_InfoDefaultTypeInternal() {}
  union {
    Game_bulletinfo_Response_Info _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_bulletinfo_Response_InfoDefaultTypeInternal _Game_bulletinfo_Response_Info_default_instance_;
PROTOBUF_CONSTEXPR Game_bulletinfo_Response::Game_bulletinfo_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_bulletinfo_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_bulletinfo_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_bulletinfo_ResponseDefaultTypeInternal() {}
  union {
    Game_bulletinfo_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_bulletinfo_ResponseDefaultTypeInternal _Game_bulletinfo_Response_default_instance_;
PROTOBUF_CONSTEXPR Game_hit_brick_Request::Game_hit_brick_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bulletinfo_)*/nullptr
  , /*decltype(_impl_.hited_brick_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_hit_brick_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_hit_brick_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_hit_brick_RequestDefaultTypeInternal() {}
  union {
    Game_hit_brick_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_hit_brick_RequestDefaultTypeInternal _Game_hit_brick_Request_default_instance_;
PROTOBUF_CONSTEXPR Game_brick_hited_Response::Game_brick_hited_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hited_brick_id_)*/0
  , /*decltype(_impl_.health_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_brick_hited_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_brick_hited_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_brick_hited_ResponseDefaultTypeInternal() {}
  union {
    Game_brick_hited_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_brick_hited_ResponseDefaultTypeInternal _Game_brick_hited_Response_default_instance_;
PROTOBUF_CONSTEXPR Game_hit_tank_Request::Game_hit_tank_Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bulletinfo_)*/nullptr
  , /*decltype(_impl_.hited_tank_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_hit_tank_RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_hit_tank_RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_hit_tank_RequestDefaultTypeInternal() {}
  union {
    Game_hit_tank_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_hit_tank_RequestDefaultTypeInternal _Game_hit_tank_Request_default_instance_;
PROTOBUF_CONSTEXPR Game_tank_hited_Response::Game_tank_hited_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hited_tank_id_)*/0
  , /*decltype(_impl_.health_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_tank_hited_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_tank_hited_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_tank_hited_ResponseDefaultTypeInternal() {}
  union {
    Game_tank_hited_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_tank_hited_ResponseDefaultTypeInternal _Game_tank_hited_Response_default_instance_;
PROTOBUF_CONSTEXPR Game_destroyed_tank_Response::Game_destroyed_tank_Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.destroyed_tank_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Game_destroyed_tank_ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Game_destroyed_tank_ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Game_destroyed_tank_ResponseDefaultTypeInternal() {}
  union {
    Game_destroyed_tank_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Game_destroyed_tank_ResponseDefaultTypeInternal _Game_destroyed_tank_Response_default_instance_;
}  // namespace Message
namespace Message {

// ===================================================================

class Hall_info_Response_User::_Internal {
 public:
};

Hall_info_Response_User::Hall_info_Response_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Hall_info_Response.User)
}
Hall_info_Response_User::Hall_info_Response_User(const Hall_info_Response_User& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Hall_info_Response_User* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Message.Hall_info_Response.User)
}

inline void Hall_info_Response_User::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Hall_info_Response_User::~Hall_info_Response_User() {
  // @@protoc_insertion_point(destructor:Message.Hall_info_Response.User)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Hall_info_Response_User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Hall_info_Response_User::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Hall_info_Response_User::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Hall_info_Response.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Hall_info_Response_User::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Hall_info_Response_User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Hall_info_Response.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Hall_info_Response.User.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Hall_info_Response.User)
  return target;
}

size_t Hall_info_Response_User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Hall_info_Response.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Hall_info_Response_User::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Hall_info_Response_User*>(
      &from));
}

void Hall_info_Response_User::MergeFrom(const Hall_info_Response_User& from) {
  Hall_info_Response_User* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Hall_info_Response.User)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Hall_info_Response_User::CopyFrom(const Hall_info_Response_User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Hall_info_Response.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hall_info_Response_User::IsInitialized() const {
  return true;
}

void Hall_info_Response_User::InternalSwap(Hall_info_Response_User* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

std::string Hall_info_Response_User::GetTypeName() const {
  return "Message.Hall_info_Response.User";
}


// ===================================================================

class Hall_info_Response_Roominfo::_Internal {
 public:
};

Hall_info_Response_Roominfo::Hall_info_Response_Roominfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Hall_info_Response.Roominfo)
}
Hall_info_Response_Roominfo::Hall_info_Response_Roominfo(const Hall_info_Response_Roominfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Hall_info_Response_Roominfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.host_name_){}
    , decltype(_impl_.room_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.host_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_host_name().empty()) {
    _this->_impl_.host_name_.Set(from._internal_host_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.room_id_ = from._impl_.room_id_;
  // @@protoc_insertion_point(copy_constructor:Message.Hall_info_Response.Roominfo)
}

inline void Hall_info_Response_Roominfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.host_name_){}
    , decltype(_impl_.room_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.host_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Hall_info_Response_Roominfo::~Hall_info_Response_Roominfo() {
  // @@protoc_insertion_point(destructor:Message.Hall_info_Response.Roominfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Hall_info_Response_Roominfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.host_name_.Destroy();
}

void Hall_info_Response_Roominfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Hall_info_Response_Roominfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Hall_info_Response.Roominfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.host_name_.ClearToEmpty();
  _impl_.room_id_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Hall_info_Response_Roominfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 room_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.room_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string host_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_host_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Hall_info_Response_Roominfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Hall_info_Response.Roominfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 room_id = 1;
  if (this->_internal_room_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_room_id(), target);
  }

  // string host_name = 2;
  if (!this->_internal_host_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_host_name().data(), static_cast<int>(this->_internal_host_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Hall_info_Response.Roominfo.host_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_host_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Hall_info_Response.Roominfo)
  return target;
}

size_t Hall_info_Response_Roominfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Hall_info_Response.Roominfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string host_name = 2;
  if (!this->_internal_host_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_host_name());
  }

  // int32 room_id = 1;
  if (this->_internal_room_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_room_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Hall_info_Response_Roominfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Hall_info_Response_Roominfo*>(
      &from));
}

void Hall_info_Response_Roominfo::MergeFrom(const Hall_info_Response_Roominfo& from) {
  Hall_info_Response_Roominfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Hall_info_Response.Roominfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_host_name().empty()) {
    _this->_internal_set_host_name(from._internal_host_name());
  }
  if (from._internal_room_id() != 0) {
    _this->_internal_set_room_id(from._internal_room_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Hall_info_Response_Roominfo::CopyFrom(const Hall_info_Response_Roominfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Hall_info_Response.Roominfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hall_info_Response_Roominfo::IsInitialized() const {
  return true;
}

void Hall_info_Response_Roominfo::InternalSwap(Hall_info_Response_Roominfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_name_, lhs_arena,
      &other->_impl_.host_name_, rhs_arena
  );
  swap(_impl_.room_id_, other->_impl_.room_id_);
}

std::string Hall_info_Response_Roominfo::GetTypeName() const {
  return "Message.Hall_info_Response.Roominfo";
}


// ===================================================================

class Hall_info_Response::_Internal {
 public:
};

Hall_info_Response::Hall_info_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Hall_info_Response)
}
Hall_info_Response::Hall_info_Response(const Hall_info_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Hall_info_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.userinfo_){from._impl_.userinfo_}
    , decltype(_impl_.roominfo_){from._impl_.roominfo_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Message.Hall_info_Response)
}

inline void Hall_info_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.userinfo_){arena}
    , decltype(_impl_.roominfo_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Hall_info_Response::~Hall_info_Response() {
  // @@protoc_insertion_point(destructor:Message.Hall_info_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Hall_info_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userinfo_.~RepeatedPtrField();
  _impl_.roominfo_.~RepeatedPtrField();
}

void Hall_info_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Hall_info_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Hall_info_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.userinfo_.Clear();
  _impl_.roominfo_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Hall_info_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Message.Hall_info_Response.User userinfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_userinfo(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Message.Hall_info_Response.Roominfo roominfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_roominfo(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Hall_info_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Hall_info_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Message.Hall_info_Response.User userinfo = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_userinfo_size()); i < n; i++) {
    const auto& repfield = this->_internal_userinfo(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Message.Hall_info_Response.Roominfo roominfo = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_roominfo_size()); i < n; i++) {
    const auto& repfield = this->_internal_roominfo(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Hall_info_Response)
  return target;
}

size_t Hall_info_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Hall_info_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Message.Hall_info_Response.User userinfo = 1;
  total_size += 1UL * this->_internal_userinfo_size();
  for (const auto& msg : this->_impl_.userinfo_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Message.Hall_info_Response.Roominfo roominfo = 2;
  total_size += 1UL * this->_internal_roominfo_size();
  for (const auto& msg : this->_impl_.roominfo_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Hall_info_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Hall_info_Response*>(
      &from));
}

void Hall_info_Response::MergeFrom(const Hall_info_Response& from) {
  Hall_info_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Hall_info_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.userinfo_.MergeFrom(from._impl_.userinfo_);
  _this->_impl_.roominfo_.MergeFrom(from._impl_.roominfo_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Hall_info_Response::CopyFrom(const Hall_info_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Hall_info_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hall_info_Response::IsInitialized() const {
  return true;
}

void Hall_info_Response::InternalSwap(Hall_info_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.userinfo_.InternalSwap(&other->_impl_.userinfo_);
  _impl_.roominfo_.InternalSwap(&other->_impl_.roominfo_);
}

std::string Hall_info_Response::GetTypeName() const {
  return "Message.Hall_info_Response";
}


// ===================================================================

class Hall_Message_Request::_Internal {
 public:
};

Hall_Message_Request::Hall_Message_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Hall_Message_Request)
}
Hall_Message_Request::Hall_Message_Request(const Hall_Message_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Hall_Message_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.content_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_content().empty()) {
    _this->_impl_.content_.Set(from._internal_content(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Message.Hall_Message_Request)
}

inline void Hall_Message_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.content_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Hall_Message_Request::~Hall_Message_Request() {
  // @@protoc_insertion_point(destructor:Message.Hall_Message_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Hall_Message_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.content_.Destroy();
}

void Hall_Message_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Hall_Message_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Hall_Message_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.content_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Hall_Message_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string content = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Hall_Message_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Hall_Message_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string content = 1;
  if (!this->_internal_content().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_content().data(), static_cast<int>(this->_internal_content().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Hall_Message_Request.content");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_content(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Hall_Message_Request)
  return target;
}

size_t Hall_Message_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Hall_Message_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string content = 1;
  if (!this->_internal_content().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_content());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Hall_Message_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Hall_Message_Request*>(
      &from));
}

void Hall_Message_Request::MergeFrom(const Hall_Message_Request& from) {
  Hall_Message_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Hall_Message_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_content().empty()) {
    _this->_internal_set_content(from._internal_content());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Hall_Message_Request::CopyFrom(const Hall_Message_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Hall_Message_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hall_Message_Request::IsInitialized() const {
  return true;
}

void Hall_Message_Request::InternalSwap(Hall_Message_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_, lhs_arena,
      &other->_impl_.content_, rhs_arena
  );
}

std::string Hall_Message_Request::GetTypeName() const {
  return "Message.Hall_Message_Request";
}


// ===================================================================

class Hall_Message_Response::_Internal {
 public:
};

Hall_Message_Response::Hall_Message_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Hall_Message_Response)
}
Hall_Message_Response::Hall_Message_Response(const Hall_Message_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Hall_Message_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.content_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_content().empty()) {
    _this->_impl_.content_.Set(from._internal_content(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Message.Hall_Message_Response)
}

inline void Hall_Message_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.content_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Hall_Message_Response::~Hall_Message_Response() {
  // @@protoc_insertion_point(destructor:Message.Hall_Message_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Hall_Message_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.content_.Destroy();
}

void Hall_Message_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Hall_Message_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Hall_Message_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.content_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Hall_Message_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string content = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Hall_Message_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Hall_Message_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Hall_Message_Response.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string content = 2;
  if (!this->_internal_content().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_content().data(), static_cast<int>(this->_internal_content().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Hall_Message_Response.content");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_content(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Hall_Message_Response)
  return target;
}

size_t Hall_Message_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Hall_Message_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string content = 2;
  if (!this->_internal_content().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_content());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Hall_Message_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Hall_Message_Response*>(
      &from));
}

void Hall_Message_Response::MergeFrom(const Hall_Message_Response& from) {
  Hall_Message_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Hall_Message_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_content().empty()) {
    _this->_internal_set_content(from._internal_content());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Hall_Message_Response::CopyFrom(const Hall_Message_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Hall_Message_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hall_Message_Response::IsInitialized() const {
  return true;
}

void Hall_Message_Response::InternalSwap(Hall_Message_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_, lhs_arena,
      &other->_impl_.content_, rhs_arena
  );
}

std::string Hall_Message_Response::GetTypeName() const {
  return "Message.Hall_Message_Response";
}


// ===================================================================

class Hall_EnterRoom_Request::_Internal {
 public:
};

Hall_EnterRoom_Request::Hall_EnterRoom_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Hall_EnterRoom_Request)
}
Hall_EnterRoom_Request::Hall_EnterRoom_Request(const Hall_EnterRoom_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Hall_EnterRoom_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.room_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.room_id_ = from._impl_.room_id_;
  // @@protoc_insertion_point(copy_constructor:Message.Hall_EnterRoom_Request)
}

inline void Hall_EnterRoom_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.room_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Hall_EnterRoom_Request::~Hall_EnterRoom_Request() {
  // @@protoc_insertion_point(destructor:Message.Hall_EnterRoom_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Hall_EnterRoom_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Hall_EnterRoom_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Hall_EnterRoom_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Hall_EnterRoom_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.room_id_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Hall_EnterRoom_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 room_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.room_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Hall_EnterRoom_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Hall_EnterRoom_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 room_id = 1;
  if (this->_internal_room_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_room_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Hall_EnterRoom_Request)
  return target;
}

size_t Hall_EnterRoom_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Hall_EnterRoom_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 room_id = 1;
  if (this->_internal_room_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_room_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Hall_EnterRoom_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Hall_EnterRoom_Request*>(
      &from));
}

void Hall_EnterRoom_Request::MergeFrom(const Hall_EnterRoom_Request& from) {
  Hall_EnterRoom_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Hall_EnterRoom_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_room_id() != 0) {
    _this->_internal_set_room_id(from._internal_room_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Hall_EnterRoom_Request::CopyFrom(const Hall_EnterRoom_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Hall_EnterRoom_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hall_EnterRoom_Request::IsInitialized() const {
  return true;
}

void Hall_EnterRoom_Request::InternalSwap(Hall_EnterRoom_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.room_id_, other->_impl_.room_id_);
}

std::string Hall_EnterRoom_Request::GetTypeName() const {
  return "Message.Hall_EnterRoom_Request";
}


// ===================================================================

class Hall_EnterRoom_Response::_Internal {
 public:
};

Hall_EnterRoom_Response::Hall_EnterRoom_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Hall_EnterRoom_Response)
}
Hall_EnterRoom_Response::Hall_EnterRoom_Response(const Hall_EnterRoom_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Hall_EnterRoom_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.room_id_){}
    , decltype(_impl_.result_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.room_id_, &from._impl_.room_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.result_) -
    reinterpret_cast<char*>(&_impl_.room_id_)) + sizeof(_impl_.result_));
  // @@protoc_insertion_point(copy_constructor:Message.Hall_EnterRoom_Response)
}

inline void Hall_EnterRoom_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.room_id_){0}
    , decltype(_impl_.result_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Hall_EnterRoom_Response::~Hall_EnterRoom_Response() {
  // @@protoc_insertion_point(destructor:Message.Hall_EnterRoom_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Hall_EnterRoom_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Hall_EnterRoom_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Hall_EnterRoom_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Hall_EnterRoom_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.room_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.result_) -
      reinterpret_cast<char*>(&_impl_.room_id_)) + sizeof(_impl_.result_));
  _internal_metadata_.Clear<std::string>();
}

const char* Hall_EnterRoom_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 room_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.room_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Hall_EnterRoom_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Hall_EnterRoom_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 room_id = 1;
  if (this->_internal_room_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_room_id(), target);
  }

  // int32 result = 2;
  if (this->_internal_result() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Hall_EnterRoom_Response)
  return target;
}

size_t Hall_EnterRoom_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Hall_EnterRoom_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 room_id = 1;
  if (this->_internal_room_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_room_id());
  }

  // int32 result = 2;
  if (this->_internal_result() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Hall_EnterRoom_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Hall_EnterRoom_Response*>(
      &from));
}

void Hall_EnterRoom_Response::MergeFrom(const Hall_EnterRoom_Response& from) {
  Hall_EnterRoom_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Hall_EnterRoom_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_room_id() != 0) {
    _this->_internal_set_room_id(from._internal_room_id());
  }
  if (from._internal_result() != 0) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Hall_EnterRoom_Response::CopyFrom(const Hall_EnterRoom_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Hall_EnterRoom_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hall_EnterRoom_Response::IsInitialized() const {
  return true;
}

void Hall_EnterRoom_Response::InternalSwap(Hall_EnterRoom_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Hall_EnterRoom_Response, _impl_.result_)
      + sizeof(Hall_EnterRoom_Response::_impl_.result_)
      - PROTOBUF_FIELD_OFFSET(Hall_EnterRoom_Response, _impl_.room_id_)>(
          reinterpret_cast<char*>(&_impl_.room_id_),
          reinterpret_cast<char*>(&other->_impl_.room_id_));
}

std::string Hall_EnterRoom_Response::GetTypeName() const {
  return "Message.Hall_EnterRoom_Response";
}


// ===================================================================

class Ping_info::_Internal {
 public:
};

Ping_info::Ping_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Ping_info)
}
Ping_info::Ping_info(const Ping_info& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Ping_info* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ping_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.ping_id_ = from._impl_.ping_id_;
  // @@protoc_insertion_point(copy_constructor:Message.Ping_info)
}

inline void Ping_info::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ping_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Ping_info::~Ping_info() {
  // @@protoc_insertion_point(destructor:Message.Ping_info)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ping_info::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ping_info::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ping_info::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Ping_info)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ping_id_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Ping_info::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 ping_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ping_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ping_info::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Ping_info)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 ping_id = 1;
  if (this->_internal_ping_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_ping_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Ping_info)
  return target;
}

size_t Ping_info::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Ping_info)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 ping_id = 1;
  if (this->_internal_ping_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ping_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ping_info::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ping_info*>(
      &from));
}

void Ping_info::MergeFrom(const Ping_info& from) {
  Ping_info* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Ping_info)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ping_id() != 0) {
    _this->_internal_set_ping_id(from._internal_ping_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ping_info::CopyFrom(const Ping_info& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Ping_info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ping_info::IsInitialized() const {
  return true;
}

void Ping_info::InternalSwap(Ping_info* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.ping_id_, other->_impl_.ping_id_);
}

std::string Ping_info::GetTypeName() const {
  return "Message.Ping_info";
}


// ===================================================================

class Set_User_id::_Internal {
 public:
};

Set_User_id::Set_User_id(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Set_User_id)
}
Set_User_id::Set_User_id(const Set_User_id& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Set_User_id* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Message.Set_User_id)
}

inline void Set_User_id::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Set_User_id::~Set_User_id() {
  // @@protoc_insertion_point(destructor:Message.Set_User_id)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Set_User_id::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Set_User_id::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Set_User_id::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Set_User_id)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Set_User_id::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Set_User_id::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Set_User_id)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Set_User_id.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Set_User_id)
  return target;
}

size_t Set_User_id::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Set_User_id)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Set_User_id::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Set_User_id*>(
      &from));
}

void Set_User_id::MergeFrom(const Set_User_id& from) {
  Set_User_id* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Set_User_id)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Set_User_id::CopyFrom(const Set_User_id& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Set_User_id)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Set_User_id::IsInitialized() const {
  return true;
}

void Set_User_id::InternalSwap(Set_User_id* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

std::string Set_User_id::GetTypeName() const {
  return "Message.Set_User_id";
}


// ===================================================================

class Room_info_Response_User::_Internal {
 public:
};

Room_info_Response_User::Room_info_Response_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Room_info_Response.User)
}
Room_info_Response_User::Room_info_Response_User(const Room_info_Response_User& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Room_info_Response_User* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:Message.Room_info_Response.User)
}

inline void Room_info_Response_User::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Room_info_Response_User::~Room_info_Response_User() {
  // @@protoc_insertion_point(destructor:Message.Room_info_Response.User)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Room_info_Response_User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Room_info_Response_User::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Room_info_Response_User::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Room_info_Response.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.status_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Room_info_Response_User::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int32 status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Room_info_Response_User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Room_info_Response.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Room_info_Response.User.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // int32 status = 2;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Room_info_Response.User)
  return target;
}

size_t Room_info_Response_User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Room_info_Response.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // int32 status = 2;
  if (this->_internal_status() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Room_info_Response_User::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Room_info_Response_User*>(
      &from));
}

void Room_info_Response_User::MergeFrom(const Room_info_Response_User& from) {
  Room_info_Response_User* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Room_info_Response.User)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Room_info_Response_User::CopyFrom(const Room_info_Response_User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Room_info_Response.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_info_Response_User::IsInitialized() const {
  return true;
}

void Room_info_Response_User::InternalSwap(Room_info_Response_User* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.status_, other->_impl_.status_);
}

std::string Room_info_Response_User::GetTypeName() const {
  return "Message.Room_info_Response.User";
}


// ===================================================================

class Room_info_Response::_Internal {
 public:
};

Room_info_Response::Room_info_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Room_info_Response)
}
Room_info_Response::Room_info_Response(const Room_info_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Room_info_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.userinfo_){from._impl_.userinfo_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Message.Room_info_Response)
}

inline void Room_info_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.userinfo_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Room_info_Response::~Room_info_Response() {
  // @@protoc_insertion_point(destructor:Message.Room_info_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Room_info_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userinfo_.~RepeatedPtrField();
}

void Room_info_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Room_info_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Room_info_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.userinfo_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Room_info_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Message.Room_info_Response.User userinfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_userinfo(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Room_info_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Room_info_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Message.Room_info_Response.User userinfo = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_userinfo_size()); i < n; i++) {
    const auto& repfield = this->_internal_userinfo(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Room_info_Response)
  return target;
}

size_t Room_info_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Room_info_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Message.Room_info_Response.User userinfo = 1;
  total_size += 1UL * this->_internal_userinfo_size();
  for (const auto& msg : this->_impl_.userinfo_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Room_info_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Room_info_Response*>(
      &from));
}

void Room_info_Response::MergeFrom(const Room_info_Response& from) {
  Room_info_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Room_info_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.userinfo_.MergeFrom(from._impl_.userinfo_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Room_info_Response::CopyFrom(const Room_info_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Room_info_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_info_Response::IsInitialized() const {
  return true;
}

void Room_info_Response::InternalSwap(Room_info_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.userinfo_.InternalSwap(&other->_impl_.userinfo_);
}

std::string Room_info_Response::GetTypeName() const {
  return "Message.Room_info_Response";
}


// ===================================================================

class Room_Message_Request::_Internal {
 public:
};

Room_Message_Request::Room_Message_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Room_Message_Request)
}
Room_Message_Request::Room_Message_Request(const Room_Message_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Room_Message_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.content_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_content().empty()) {
    _this->_impl_.content_.Set(from._internal_content(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Message.Room_Message_Request)
}

inline void Room_Message_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.content_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Room_Message_Request::~Room_Message_Request() {
  // @@protoc_insertion_point(destructor:Message.Room_Message_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Room_Message_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.content_.Destroy();
}

void Room_Message_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Room_Message_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Room_Message_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.content_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Room_Message_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string content = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Room_Message_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Room_Message_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string content = 1;
  if (!this->_internal_content().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_content().data(), static_cast<int>(this->_internal_content().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Room_Message_Request.content");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_content(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Room_Message_Request)
  return target;
}

size_t Room_Message_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Room_Message_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string content = 1;
  if (!this->_internal_content().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_content());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Room_Message_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Room_Message_Request*>(
      &from));
}

void Room_Message_Request::MergeFrom(const Room_Message_Request& from) {
  Room_Message_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Room_Message_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_content().empty()) {
    _this->_internal_set_content(from._internal_content());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Room_Message_Request::CopyFrom(const Room_Message_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Room_Message_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_Message_Request::IsInitialized() const {
  return true;
}

void Room_Message_Request::InternalSwap(Room_Message_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_, lhs_arena,
      &other->_impl_.content_, rhs_arena
  );
}

std::string Room_Message_Request::GetTypeName() const {
  return "Message.Room_Message_Request";
}


// ===================================================================

class Room_Message_Response::_Internal {
 public:
};

Room_Message_Response::Room_Message_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Room_Message_Response)
}
Room_Message_Response::Room_Message_Response(const Room_Message_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Room_Message_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.content_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_content().empty()) {
    _this->_impl_.content_.Set(from._internal_content(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Message.Room_Message_Response)
}

inline void Room_Message_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.content_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Room_Message_Response::~Room_Message_Response() {
  // @@protoc_insertion_point(destructor:Message.Room_Message_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Room_Message_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.content_.Destroy();
}

void Room_Message_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Room_Message_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Room_Message_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.content_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* Room_Message_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string content = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Room_Message_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Room_Message_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Room_Message_Response.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string content = 2;
  if (!this->_internal_content().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_content().data(), static_cast<int>(this->_internal_content().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Message.Room_Message_Response.content");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_content(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Room_Message_Response)
  return target;
}

size_t Room_Message_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Room_Message_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string content = 2;
  if (!this->_internal_content().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_content());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Room_Message_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Room_Message_Response*>(
      &from));
}

void Room_Message_Response::MergeFrom(const Room_Message_Response& from) {
  Room_Message_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Room_Message_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_content().empty()) {
    _this->_internal_set_content(from._internal_content());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Room_Message_Response::CopyFrom(const Room_Message_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Room_Message_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_Message_Response::IsInitialized() const {
  return true;
}

void Room_Message_Response::InternalSwap(Room_Message_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_, lhs_arena,
      &other->_impl_.content_, rhs_arena
  );
}

std::string Room_Message_Response::GetTypeName() const {
  return "Message.Room_Message_Response";
}


// ===================================================================

class Room_Set_tankid::_Internal {
 public:
};

Room_Set_tankid::Room_Set_tankid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Room_Set_tankid)
}
Room_Set_tankid::Room_Set_tankid(const Room_Set_tankid& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Room_Set_tankid* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:Message.Room_Set_tankid)
}

inline void Room_Set_tankid::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Room_Set_tankid::~Room_Set_tankid() {
  // @@protoc_insertion_point(destructor:Message.Room_Set_tankid)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Room_Set_tankid::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Room_Set_tankid::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Room_Set_tankid::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Room_Set_tankid)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Room_Set_tankid::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Room_Set_tankid::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Room_Set_tankid)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Room_Set_tankid)
  return target;
}

size_t Room_Set_tankid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Room_Set_tankid)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Room_Set_tankid::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Room_Set_tankid*>(
      &from));
}

void Room_Set_tankid::MergeFrom(const Room_Set_tankid& from) {
  Room_Set_tankid* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Room_Set_tankid)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Room_Set_tankid::CopyFrom(const Room_Set_tankid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Room_Set_tankid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_Set_tankid::IsInitialized() const {
  return true;
}

void Room_Set_tankid::InternalSwap(Room_Set_tankid* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.id_, other->_impl_.id_);
}

std::string Room_Set_tankid::GetTypeName() const {
  return "Message.Room_Set_tankid";
}


// ===================================================================

class Room_Set_tankid_Response::_Internal {
 public:
};

Room_Set_tankid_Response::Room_Set_tankid_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Room_Set_tankid_Response)
}
Room_Set_tankid_Response::Room_Set_tankid_Response(const Room_Set_tankid_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Room_Set_tankid_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:Message.Room_Set_tankid_Response)
}

inline void Room_Set_tankid_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Room_Set_tankid_Response::~Room_Set_tankid_Response() {
  // @@protoc_insertion_point(destructor:Message.Room_Set_tankid_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Room_Set_tankid_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Room_Set_tankid_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Room_Set_tankid_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Room_Set_tankid_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Room_Set_tankid_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Room_Set_tankid_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Room_Set_tankid_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Room_Set_tankid_Response)
  return target;
}

size_t Room_Set_tankid_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Room_Set_tankid_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Room_Set_tankid_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Room_Set_tankid_Response*>(
      &from));
}

void Room_Set_tankid_Response::MergeFrom(const Room_Set_tankid_Response& from) {
  Room_Set_tankid_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Room_Set_tankid_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Room_Set_tankid_Response::CopyFrom(const Room_Set_tankid_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Room_Set_tankid_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_Set_tankid_Response::IsInitialized() const {
  return true;
}

void Room_Set_tankid_Response::InternalSwap(Room_Set_tankid_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.id_, other->_impl_.id_);
}

std::string Room_Set_tankid_Response::GetTypeName() const {
  return "Message.Room_Set_tankid_Response";
}


// ===================================================================

class Room_Start_Response::_Internal {
 public:
};

Room_Start_Response::Room_Start_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Room_Start_Response)
}
Room_Start_Response::Room_Start_Response(const Room_Start_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Room_Start_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.result_ = from._impl_.result_;
  // @@protoc_insertion_point(copy_constructor:Message.Room_Start_Response)
}

inline void Room_Start_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.result_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Room_Start_Response::~Room_Start_Response() {
  // @@protoc_insertion_point(destructor:Message.Room_Start_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Room_Start_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Room_Start_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Room_Start_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Room_Start_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Room_Start_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Room_Start_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Room_Start_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 result = 1;
  if (this->_internal_result() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Room_Start_Response)
  return target;
}

size_t Room_Start_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Room_Start_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 result = 1;
  if (this->_internal_result() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Room_Start_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Room_Start_Response*>(
      &from));
}

void Room_Start_Response::MergeFrom(const Room_Start_Response& from) {
  Room_Start_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Room_Start_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_result() != 0) {
    _this->_internal_set_result(from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Room_Start_Response::CopyFrom(const Room_Start_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Room_Start_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_Start_Response::IsInitialized() const {
  return true;
}

void Room_Start_Response::InternalSwap(Room_Start_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.result_, other->_impl_.result_);
}

std::string Room_Start_Response::GetTypeName() const {
  return "Message.Room_Start_Response";
}


// ===================================================================

class Game_tankinfo_Request::_Internal {
 public:
};

Game_tankinfo_Request::Game_tankinfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_tankinfo_Request)
}
Game_tankinfo_Request::Game_tankinfo_Request(const Game_tankinfo_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_tankinfo_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.locationx_){}
    , decltype(_impl_.locationy_){}
    , decltype(_impl_.rotate_){}
    , decltype(_impl_.tank_style_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.locationx_, &from._impl_.locationx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tank_style_) -
    reinterpret_cast<char*>(&_impl_.locationx_)) + sizeof(_impl_.tank_style_));
  // @@protoc_insertion_point(copy_constructor:Message.Game_tankinfo_Request)
}

inline void Game_tankinfo_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.locationx_){0}
    , decltype(_impl_.locationy_){0}
    , decltype(_impl_.rotate_){0}
    , decltype(_impl_.tank_style_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_tankinfo_Request::~Game_tankinfo_Request() {
  // @@protoc_insertion_point(destructor:Message.Game_tankinfo_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_tankinfo_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Game_tankinfo_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_tankinfo_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_tankinfo_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.locationx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tank_style_) -
      reinterpret_cast<char*>(&_impl_.locationx_)) + sizeof(_impl_.tank_style_));
  _internal_metadata_.Clear<std::string>();
}

const char* Game_tankinfo_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double locationX = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.locationx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double locationY = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.locationy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rotate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.rotate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 tank_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.tank_style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_tankinfo_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_tankinfo_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double locationX = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationx = this->_internal_locationx();
  uint64_t raw_locationx;
  memcpy(&raw_locationx, &tmp_locationx, sizeof(tmp_locationx));
  if (raw_locationx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_locationx(), target);
  }

  // double locationY = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationy = this->_internal_locationy();
  uint64_t raw_locationy;
  memcpy(&raw_locationy, &tmp_locationy, sizeof(tmp_locationy));
  if (raw_locationy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_locationy(), target);
  }

  // double rotate = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rotate = this->_internal_rotate();
  uint64_t raw_rotate;
  memcpy(&raw_rotate, &tmp_rotate, sizeof(tmp_rotate));
  if (raw_rotate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_rotate(), target);
  }

  // int32 tank_style = 4;
  if (this->_internal_tank_style() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_tank_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_tankinfo_Request)
  return target;
}

size_t Game_tankinfo_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_tankinfo_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double locationX = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationx = this->_internal_locationx();
  uint64_t raw_locationx;
  memcpy(&raw_locationx, &tmp_locationx, sizeof(tmp_locationx));
  if (raw_locationx != 0) {
    total_size += 1 + 8;
  }

  // double locationY = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationy = this->_internal_locationy();
  uint64_t raw_locationy;
  memcpy(&raw_locationy, &tmp_locationy, sizeof(tmp_locationy));
  if (raw_locationy != 0) {
    total_size += 1 + 8;
  }

  // double rotate = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rotate = this->_internal_rotate();
  uint64_t raw_rotate;
  memcpy(&raw_rotate, &tmp_rotate, sizeof(tmp_rotate));
  if (raw_rotate != 0) {
    total_size += 1 + 8;
  }

  // int32 tank_style = 4;
  if (this->_internal_tank_style() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tank_style());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_tankinfo_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_tankinfo_Request*>(
      &from));
}

void Game_tankinfo_Request::MergeFrom(const Game_tankinfo_Request& from) {
  Game_tankinfo_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_tankinfo_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationx = from._internal_locationx();
  uint64_t raw_locationx;
  memcpy(&raw_locationx, &tmp_locationx, sizeof(tmp_locationx));
  if (raw_locationx != 0) {
    _this->_internal_set_locationx(from._internal_locationx());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationy = from._internal_locationy();
  uint64_t raw_locationy;
  memcpy(&raw_locationy, &tmp_locationy, sizeof(tmp_locationy));
  if (raw_locationy != 0) {
    _this->_internal_set_locationy(from._internal_locationy());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rotate = from._internal_rotate();
  uint64_t raw_rotate;
  memcpy(&raw_rotate, &tmp_rotate, sizeof(tmp_rotate));
  if (raw_rotate != 0) {
    _this->_internal_set_rotate(from._internal_rotate());
  }
  if (from._internal_tank_style() != 0) {
    _this->_internal_set_tank_style(from._internal_tank_style());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_tankinfo_Request::CopyFrom(const Game_tankinfo_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_tankinfo_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_tankinfo_Request::IsInitialized() const {
  return true;
}

void Game_tankinfo_Request::InternalSwap(Game_tankinfo_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Game_tankinfo_Request, _impl_.tank_style_)
      + sizeof(Game_tankinfo_Request::_impl_.tank_style_)
      - PROTOBUF_FIELD_OFFSET(Game_tankinfo_Request, _impl_.locationx_)>(
          reinterpret_cast<char*>(&_impl_.locationx_),
          reinterpret_cast<char*>(&other->_impl_.locationx_));
}

std::string Game_tankinfo_Request::GetTypeName() const {
  return "Message.Game_tankinfo_Request";
}


// ===================================================================

class Game_tankinfo_Response_tankinfo::_Internal {
 public:
  static const ::Message::Game_tankinfo_Request& tankinfo(const Game_tankinfo_Response_tankinfo* msg);
};

const ::Message::Game_tankinfo_Request&
Game_tankinfo_Response_tankinfo::_Internal::tankinfo(const Game_tankinfo_Response_tankinfo* msg) {
  return *msg->_impl_.tankinfo_;
}
Game_tankinfo_Response_tankinfo::Game_tankinfo_Response_tankinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_tankinfo_Response.tankinfo)
}
Game_tankinfo_Response_tankinfo::Game_tankinfo_Response_tankinfo(const Game_tankinfo_Response_tankinfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_tankinfo_Response_tankinfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tankinfo_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.health_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_tankinfo()) {
    _this->_impl_.tankinfo_ = new ::Message::Game_tankinfo_Request(*from._impl_.tankinfo_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.health_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.health_));
  // @@protoc_insertion_point(copy_constructor:Message.Game_tankinfo_Response.tankinfo)
}

inline void Game_tankinfo_Response_tankinfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tankinfo_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.health_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_tankinfo_Response_tankinfo::~Game_tankinfo_Response_tankinfo() {
  // @@protoc_insertion_point(destructor:Message.Game_tankinfo_Response.tankinfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_tankinfo_Response_tankinfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tankinfo_;
}

void Game_tankinfo_Response_tankinfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_tankinfo_Response_tankinfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_tankinfo_Response.tankinfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.tankinfo_ != nullptr) {
    delete _impl_.tankinfo_;
  }
  _impl_.tankinfo_ = nullptr;
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.health_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.health_));
  _internal_metadata_.Clear<std::string>();
}

const char* Game_tankinfo_Response_tankinfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Message.Game_tankinfo_Request tankinfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tankinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 health = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.health_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_tankinfo_Response_tankinfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_tankinfo_Response.tankinfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // .Message.Game_tankinfo_Request tankinfo = 2;
  if (this->_internal_has_tankinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tankinfo(this),
        _Internal::tankinfo(this).GetCachedSize(), target, stream);
  }

  // int32 health = 3;
  if (this->_internal_health() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_health(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_tankinfo_Response.tankinfo)
  return target;
}

size_t Game_tankinfo_Response_tankinfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_tankinfo_Response.tankinfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Message.Game_tankinfo_Request tankinfo = 2;
  if (this->_internal_has_tankinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tankinfo_);
  }

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 health = 3;
  if (this->_internal_health() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_health());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_tankinfo_Response_tankinfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_tankinfo_Response_tankinfo*>(
      &from));
}

void Game_tankinfo_Response_tankinfo::MergeFrom(const Game_tankinfo_Response_tankinfo& from) {
  Game_tankinfo_Response_tankinfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_tankinfo_Response.tankinfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tankinfo()) {
    _this->_internal_mutable_tankinfo()->::Message::Game_tankinfo_Request::MergeFrom(
        from._internal_tankinfo());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_health() != 0) {
    _this->_internal_set_health(from._internal_health());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_tankinfo_Response_tankinfo::CopyFrom(const Game_tankinfo_Response_tankinfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_tankinfo_Response.tankinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_tankinfo_Response_tankinfo::IsInitialized() const {
  return true;
}

void Game_tankinfo_Response_tankinfo::InternalSwap(Game_tankinfo_Response_tankinfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Game_tankinfo_Response_tankinfo, _impl_.health_)
      + sizeof(Game_tankinfo_Response_tankinfo::_impl_.health_)
      - PROTOBUF_FIELD_OFFSET(Game_tankinfo_Response_tankinfo, _impl_.tankinfo_)>(
          reinterpret_cast<char*>(&_impl_.tankinfo_),
          reinterpret_cast<char*>(&other->_impl_.tankinfo_));
}

std::string Game_tankinfo_Response_tankinfo::GetTypeName() const {
  return "Message.Game_tankinfo_Response.tankinfo";
}


// ===================================================================

class Game_tankinfo_Response::_Internal {
 public:
};

Game_tankinfo_Response::Game_tankinfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_tankinfo_Response)
}
Game_tankinfo_Response::Game_tankinfo_Response(const Game_tankinfo_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_tankinfo_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){from._impl_.info_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Message.Game_tankinfo_Response)
}

inline void Game_tankinfo_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_tankinfo_Response::~Game_tankinfo_Response() {
  // @@protoc_insertion_point(destructor:Message.Game_tankinfo_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_tankinfo_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.info_.~RepeatedPtrField();
}

void Game_tankinfo_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_tankinfo_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_tankinfo_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.info_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Game_tankinfo_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Message.Game_tankinfo_Response.tankinfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_tankinfo_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_tankinfo_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Message.Game_tankinfo_Response.tankinfo info = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_tankinfo_Response)
  return target;
}

size_t Game_tankinfo_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_tankinfo_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Message.Game_tankinfo_Response.tankinfo info = 1;
  total_size += 1UL * this->_internal_info_size();
  for (const auto& msg : this->_impl_.info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_tankinfo_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_tankinfo_Response*>(
      &from));
}

void Game_tankinfo_Response::MergeFrom(const Game_tankinfo_Response& from) {
  Game_tankinfo_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_tankinfo_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.info_.MergeFrom(from._impl_.info_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_tankinfo_Response::CopyFrom(const Game_tankinfo_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_tankinfo_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_tankinfo_Response::IsInitialized() const {
  return true;
}

void Game_tankinfo_Response::InternalSwap(Game_tankinfo_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.info_.InternalSwap(&other->_impl_.info_);
}

std::string Game_tankinfo_Response::GetTypeName() const {
  return "Message.Game_tankinfo_Response";
}


// ===================================================================

class bulletinfo::_Internal {
 public:
};

bulletinfo::bulletinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.bulletinfo)
}
bulletinfo::bulletinfo(const bulletinfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  bulletinfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.locationx_){}
    , decltype(_impl_.locationy_){}
    , decltype(_impl_.rotate_){}
    , decltype(_impl_.bullet_style_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.locationx_, &from._impl_.locationx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bullet_style_) -
    reinterpret_cast<char*>(&_impl_.locationx_)) + sizeof(_impl_.bullet_style_));
  // @@protoc_insertion_point(copy_constructor:Message.bulletinfo)
}

inline void bulletinfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.locationx_){0}
    , decltype(_impl_.locationy_){0}
    , decltype(_impl_.rotate_){0}
    , decltype(_impl_.bullet_style_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

bulletinfo::~bulletinfo() {
  // @@protoc_insertion_point(destructor:Message.bulletinfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void bulletinfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void bulletinfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void bulletinfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.bulletinfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.locationx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.bullet_style_) -
      reinterpret_cast<char*>(&_impl_.locationx_)) + sizeof(_impl_.bullet_style_));
  _internal_metadata_.Clear<std::string>();
}

const char* bulletinfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double locationX = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.locationx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double locationY = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.locationy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rotate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.rotate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 bullet_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.bullet_style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* bulletinfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.bulletinfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double locationX = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationx = this->_internal_locationx();
  uint64_t raw_locationx;
  memcpy(&raw_locationx, &tmp_locationx, sizeof(tmp_locationx));
  if (raw_locationx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_locationx(), target);
  }

  // double locationY = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationy = this->_internal_locationy();
  uint64_t raw_locationy;
  memcpy(&raw_locationy, &tmp_locationy, sizeof(tmp_locationy));
  if (raw_locationy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_locationy(), target);
  }

  // double rotate = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rotate = this->_internal_rotate();
  uint64_t raw_rotate;
  memcpy(&raw_rotate, &tmp_rotate, sizeof(tmp_rotate));
  if (raw_rotate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_rotate(), target);
  }

  // int32 bullet_style = 4;
  if (this->_internal_bullet_style() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_bullet_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.bulletinfo)
  return target;
}

size_t bulletinfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.bulletinfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double locationX = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationx = this->_internal_locationx();
  uint64_t raw_locationx;
  memcpy(&raw_locationx, &tmp_locationx, sizeof(tmp_locationx));
  if (raw_locationx != 0) {
    total_size += 1 + 8;
  }

  // double locationY = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationy = this->_internal_locationy();
  uint64_t raw_locationy;
  memcpy(&raw_locationy, &tmp_locationy, sizeof(tmp_locationy));
  if (raw_locationy != 0) {
    total_size += 1 + 8;
  }

  // double rotate = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rotate = this->_internal_rotate();
  uint64_t raw_rotate;
  memcpy(&raw_rotate, &tmp_rotate, sizeof(tmp_rotate));
  if (raw_rotate != 0) {
    total_size += 1 + 8;
  }

  // int32 bullet_style = 4;
  if (this->_internal_bullet_style() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bullet_style());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void bulletinfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const bulletinfo*>(
      &from));
}

void bulletinfo::MergeFrom(const bulletinfo& from) {
  bulletinfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.bulletinfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationx = from._internal_locationx();
  uint64_t raw_locationx;
  memcpy(&raw_locationx, &tmp_locationx, sizeof(tmp_locationx));
  if (raw_locationx != 0) {
    _this->_internal_set_locationx(from._internal_locationx());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_locationy = from._internal_locationy();
  uint64_t raw_locationy;
  memcpy(&raw_locationy, &tmp_locationy, sizeof(tmp_locationy));
  if (raw_locationy != 0) {
    _this->_internal_set_locationy(from._internal_locationy());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rotate = from._internal_rotate();
  uint64_t raw_rotate;
  memcpy(&raw_rotate, &tmp_rotate, sizeof(tmp_rotate));
  if (raw_rotate != 0) {
    _this->_internal_set_rotate(from._internal_rotate());
  }
  if (from._internal_bullet_style() != 0) {
    _this->_internal_set_bullet_style(from._internal_bullet_style());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void bulletinfo::CopyFrom(const bulletinfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.bulletinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool bulletinfo::IsInitialized() const {
  return true;
}

void bulletinfo::InternalSwap(bulletinfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(bulletinfo, _impl_.bullet_style_)
      + sizeof(bulletinfo::_impl_.bullet_style_)
      - PROTOBUF_FIELD_OFFSET(bulletinfo, _impl_.locationx_)>(
          reinterpret_cast<char*>(&_impl_.locationx_),
          reinterpret_cast<char*>(&other->_impl_.locationx_));
}

std::string bulletinfo::GetTypeName() const {
  return "Message.bulletinfo";
}


// ===================================================================

class Game_bulletinfo_Request::_Internal {
 public:
};

Game_bulletinfo_Request::Game_bulletinfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_bulletinfo_Request)
}
Game_bulletinfo_Request::Game_bulletinfo_Request(const Game_bulletinfo_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_bulletinfo_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bulletinfo_){from._impl_.bulletinfo_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Message.Game_bulletinfo_Request)
}

inline void Game_bulletinfo_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bulletinfo_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_bulletinfo_Request::~Game_bulletinfo_Request() {
  // @@protoc_insertion_point(destructor:Message.Game_bulletinfo_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_bulletinfo_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bulletinfo_.~RepeatedPtrField();
}

void Game_bulletinfo_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_bulletinfo_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_bulletinfo_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bulletinfo_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Game_bulletinfo_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Message.bulletinfo bulletinfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bulletinfo(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_bulletinfo_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_bulletinfo_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Message.bulletinfo bulletinfo = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bulletinfo_size()); i < n; i++) {
    const auto& repfield = this->_internal_bulletinfo(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_bulletinfo_Request)
  return target;
}

size_t Game_bulletinfo_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_bulletinfo_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Message.bulletinfo bulletinfo = 2;
  total_size += 1UL * this->_internal_bulletinfo_size();
  for (const auto& msg : this->_impl_.bulletinfo_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_bulletinfo_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_bulletinfo_Request*>(
      &from));
}

void Game_bulletinfo_Request::MergeFrom(const Game_bulletinfo_Request& from) {
  Game_bulletinfo_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_bulletinfo_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bulletinfo_.MergeFrom(from._impl_.bulletinfo_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_bulletinfo_Request::CopyFrom(const Game_bulletinfo_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_bulletinfo_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_bulletinfo_Request::IsInitialized() const {
  return true;
}

void Game_bulletinfo_Request::InternalSwap(Game_bulletinfo_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bulletinfo_.InternalSwap(&other->_impl_.bulletinfo_);
}

std::string Game_bulletinfo_Request::GetTypeName() const {
  return "Message.Game_bulletinfo_Request";
}


// ===================================================================

class Game_bulletinfo_Response_Info::_Internal {
 public:
};

Game_bulletinfo_Response_Info::Game_bulletinfo_Response_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_bulletinfo_Response.Info)
}
Game_bulletinfo_Response_Info::Game_bulletinfo_Response_Info(const Game_bulletinfo_Response_Info& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_bulletinfo_Response_Info* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bulletinfo_){from._impl_.bulletinfo_}
    , decltype(_impl_.tankid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.tankid_ = from._impl_.tankid_;
  // @@protoc_insertion_point(copy_constructor:Message.Game_bulletinfo_Response.Info)
}

inline void Game_bulletinfo_Response_Info::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bulletinfo_){arena}
    , decltype(_impl_.tankid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_bulletinfo_Response_Info::~Game_bulletinfo_Response_Info() {
  // @@protoc_insertion_point(destructor:Message.Game_bulletinfo_Response.Info)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_bulletinfo_Response_Info::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bulletinfo_.~RepeatedPtrField();
}

void Game_bulletinfo_Response_Info::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_bulletinfo_Response_Info::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_bulletinfo_Response.Info)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bulletinfo_.Clear();
  _impl_.tankid_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Game_bulletinfo_Response_Info::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 tankid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.tankid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Message.bulletinfo bulletinfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bulletinfo(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_bulletinfo_Response_Info::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_bulletinfo_Response.Info)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 tankid = 1;
  if (this->_internal_tankid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tankid(), target);
  }

  // repeated .Message.bulletinfo bulletinfo = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bulletinfo_size()); i < n; i++) {
    const auto& repfield = this->_internal_bulletinfo(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_bulletinfo_Response.Info)
  return target;
}

size_t Game_bulletinfo_Response_Info::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_bulletinfo_Response.Info)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Message.bulletinfo bulletinfo = 2;
  total_size += 1UL * this->_internal_bulletinfo_size();
  for (const auto& msg : this->_impl_.bulletinfo_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 tankid = 1;
  if (this->_internal_tankid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tankid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_bulletinfo_Response_Info::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_bulletinfo_Response_Info*>(
      &from));
}

void Game_bulletinfo_Response_Info::MergeFrom(const Game_bulletinfo_Response_Info& from) {
  Game_bulletinfo_Response_Info* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_bulletinfo_Response.Info)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bulletinfo_.MergeFrom(from._impl_.bulletinfo_);
  if (from._internal_tankid() != 0) {
    _this->_internal_set_tankid(from._internal_tankid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_bulletinfo_Response_Info::CopyFrom(const Game_bulletinfo_Response_Info& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_bulletinfo_Response.Info)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_bulletinfo_Response_Info::IsInitialized() const {
  return true;
}

void Game_bulletinfo_Response_Info::InternalSwap(Game_bulletinfo_Response_Info* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bulletinfo_.InternalSwap(&other->_impl_.bulletinfo_);
  swap(_impl_.tankid_, other->_impl_.tankid_);
}

std::string Game_bulletinfo_Response_Info::GetTypeName() const {
  return "Message.Game_bulletinfo_Response.Info";
}


// ===================================================================

class Game_bulletinfo_Response::_Internal {
 public:
};

Game_bulletinfo_Response::Game_bulletinfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_bulletinfo_Response)
}
Game_bulletinfo_Response::Game_bulletinfo_Response(const Game_bulletinfo_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_bulletinfo_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){from._impl_.info_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Message.Game_bulletinfo_Response)
}

inline void Game_bulletinfo_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_bulletinfo_Response::~Game_bulletinfo_Response() {
  // @@protoc_insertion_point(destructor:Message.Game_bulletinfo_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_bulletinfo_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.info_.~RepeatedPtrField();
}

void Game_bulletinfo_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_bulletinfo_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_bulletinfo_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.info_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Game_bulletinfo_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Message.Game_bulletinfo_Response.Info info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_bulletinfo_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_bulletinfo_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Message.Game_bulletinfo_Response.Info info = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_bulletinfo_Response)
  return target;
}

size_t Game_bulletinfo_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_bulletinfo_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Message.Game_bulletinfo_Response.Info info = 1;
  total_size += 1UL * this->_internal_info_size();
  for (const auto& msg : this->_impl_.info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_bulletinfo_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_bulletinfo_Response*>(
      &from));
}

void Game_bulletinfo_Response::MergeFrom(const Game_bulletinfo_Response& from) {
  Game_bulletinfo_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_bulletinfo_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.info_.MergeFrom(from._impl_.info_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_bulletinfo_Response::CopyFrom(const Game_bulletinfo_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_bulletinfo_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_bulletinfo_Response::IsInitialized() const {
  return true;
}

void Game_bulletinfo_Response::InternalSwap(Game_bulletinfo_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.info_.InternalSwap(&other->_impl_.info_);
}

std::string Game_bulletinfo_Response::GetTypeName() const {
  return "Message.Game_bulletinfo_Response";
}


// ===================================================================

class Game_hit_brick_Request::_Internal {
 public:
  static const ::Message::bulletinfo& bulletinfo(const Game_hit_brick_Request* msg);
};

const ::Message::bulletinfo&
Game_hit_brick_Request::_Internal::bulletinfo(const Game_hit_brick_Request* msg) {
  return *msg->_impl_.bulletinfo_;
}
Game_hit_brick_Request::Game_hit_brick_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_hit_brick_Request)
}
Game_hit_brick_Request::Game_hit_brick_Request(const Game_hit_brick_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_hit_brick_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bulletinfo_){nullptr}
    , decltype(_impl_.hited_brick_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_bulletinfo()) {
    _this->_impl_.bulletinfo_ = new ::Message::bulletinfo(*from._impl_.bulletinfo_);
  }
  _this->_impl_.hited_brick_id_ = from._impl_.hited_brick_id_;
  // @@protoc_insertion_point(copy_constructor:Message.Game_hit_brick_Request)
}

inline void Game_hit_brick_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bulletinfo_){nullptr}
    , decltype(_impl_.hited_brick_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_hit_brick_Request::~Game_hit_brick_Request() {
  // @@protoc_insertion_point(destructor:Message.Game_hit_brick_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_hit_brick_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.bulletinfo_;
}

void Game_hit_brick_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_hit_brick_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_hit_brick_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.bulletinfo_ != nullptr) {
    delete _impl_.bulletinfo_;
  }
  _impl_.bulletinfo_ = nullptr;
  _impl_.hited_brick_id_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Game_hit_brick_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 hited_brick_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hited_brick_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Message.bulletinfo bulletinfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_bulletinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_hit_brick_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_hit_brick_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 hited_brick_id = 1;
  if (this->_internal_hited_brick_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hited_brick_id(), target);
  }

  // .Message.bulletinfo bulletinfo = 2;
  if (this->_internal_has_bulletinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::bulletinfo(this),
        _Internal::bulletinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_hit_brick_Request)
  return target;
}

size_t Game_hit_brick_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_hit_brick_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Message.bulletinfo bulletinfo = 2;
  if (this->_internal_has_bulletinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bulletinfo_);
  }

  // int32 hited_brick_id = 1;
  if (this->_internal_hited_brick_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hited_brick_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_hit_brick_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_hit_brick_Request*>(
      &from));
}

void Game_hit_brick_Request::MergeFrom(const Game_hit_brick_Request& from) {
  Game_hit_brick_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_hit_brick_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_bulletinfo()) {
    _this->_internal_mutable_bulletinfo()->::Message::bulletinfo::MergeFrom(
        from._internal_bulletinfo());
  }
  if (from._internal_hited_brick_id() != 0) {
    _this->_internal_set_hited_brick_id(from._internal_hited_brick_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_hit_brick_Request::CopyFrom(const Game_hit_brick_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_hit_brick_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_hit_brick_Request::IsInitialized() const {
  return true;
}

void Game_hit_brick_Request::InternalSwap(Game_hit_brick_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Game_hit_brick_Request, _impl_.hited_brick_id_)
      + sizeof(Game_hit_brick_Request::_impl_.hited_brick_id_)
      - PROTOBUF_FIELD_OFFSET(Game_hit_brick_Request, _impl_.bulletinfo_)>(
          reinterpret_cast<char*>(&_impl_.bulletinfo_),
          reinterpret_cast<char*>(&other->_impl_.bulletinfo_));
}

std::string Game_hit_brick_Request::GetTypeName() const {
  return "Message.Game_hit_brick_Request";
}


// ===================================================================

class Game_brick_hited_Response::_Internal {
 public:
};

Game_brick_hited_Response::Game_brick_hited_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_brick_hited_Response)
}
Game_brick_hited_Response::Game_brick_hited_Response(const Game_brick_hited_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_brick_hited_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hited_brick_id_){}
    , decltype(_impl_.health_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.hited_brick_id_, &from._impl_.hited_brick_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.health_) -
    reinterpret_cast<char*>(&_impl_.hited_brick_id_)) + sizeof(_impl_.health_));
  // @@protoc_insertion_point(copy_constructor:Message.Game_brick_hited_Response)
}

inline void Game_brick_hited_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hited_brick_id_){0}
    , decltype(_impl_.health_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_brick_hited_Response::~Game_brick_hited_Response() {
  // @@protoc_insertion_point(destructor:Message.Game_brick_hited_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_brick_hited_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Game_brick_hited_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_brick_hited_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_brick_hited_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.hited_brick_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.health_) -
      reinterpret_cast<char*>(&_impl_.hited_brick_id_)) + sizeof(_impl_.health_));
  _internal_metadata_.Clear<std::string>();
}

const char* Game_brick_hited_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 hited_brick_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hited_brick_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 health = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.health_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_brick_hited_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_brick_hited_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 hited_brick_id = 1;
  if (this->_internal_hited_brick_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hited_brick_id(), target);
  }

  // int32 health = 2;
  if (this->_internal_health() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_health(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_brick_hited_Response)
  return target;
}

size_t Game_brick_hited_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_brick_hited_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 hited_brick_id = 1;
  if (this->_internal_hited_brick_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hited_brick_id());
  }

  // int32 health = 2;
  if (this->_internal_health() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_health());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_brick_hited_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_brick_hited_Response*>(
      &from));
}

void Game_brick_hited_Response::MergeFrom(const Game_brick_hited_Response& from) {
  Game_brick_hited_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_brick_hited_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_hited_brick_id() != 0) {
    _this->_internal_set_hited_brick_id(from._internal_hited_brick_id());
  }
  if (from._internal_health() != 0) {
    _this->_internal_set_health(from._internal_health());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_brick_hited_Response::CopyFrom(const Game_brick_hited_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_brick_hited_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_brick_hited_Response::IsInitialized() const {
  return true;
}

void Game_brick_hited_Response::InternalSwap(Game_brick_hited_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Game_brick_hited_Response, _impl_.health_)
      + sizeof(Game_brick_hited_Response::_impl_.health_)
      - PROTOBUF_FIELD_OFFSET(Game_brick_hited_Response, _impl_.hited_brick_id_)>(
          reinterpret_cast<char*>(&_impl_.hited_brick_id_),
          reinterpret_cast<char*>(&other->_impl_.hited_brick_id_));
}

std::string Game_brick_hited_Response::GetTypeName() const {
  return "Message.Game_brick_hited_Response";
}


// ===================================================================

class Game_hit_tank_Request::_Internal {
 public:
  static const ::Message::bulletinfo& bulletinfo(const Game_hit_tank_Request* msg);
};

const ::Message::bulletinfo&
Game_hit_tank_Request::_Internal::bulletinfo(const Game_hit_tank_Request* msg) {
  return *msg->_impl_.bulletinfo_;
}
Game_hit_tank_Request::Game_hit_tank_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_hit_tank_Request)
}
Game_hit_tank_Request::Game_hit_tank_Request(const Game_hit_tank_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_hit_tank_Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bulletinfo_){nullptr}
    , decltype(_impl_.hited_tank_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_bulletinfo()) {
    _this->_impl_.bulletinfo_ = new ::Message::bulletinfo(*from._impl_.bulletinfo_);
  }
  _this->_impl_.hited_tank_id_ = from._impl_.hited_tank_id_;
  // @@protoc_insertion_point(copy_constructor:Message.Game_hit_tank_Request)
}

inline void Game_hit_tank_Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bulletinfo_){nullptr}
    , decltype(_impl_.hited_tank_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_hit_tank_Request::~Game_hit_tank_Request() {
  // @@protoc_insertion_point(destructor:Message.Game_hit_tank_Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_hit_tank_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.bulletinfo_;
}

void Game_hit_tank_Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_hit_tank_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_hit_tank_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.bulletinfo_ != nullptr) {
    delete _impl_.bulletinfo_;
  }
  _impl_.bulletinfo_ = nullptr;
  _impl_.hited_tank_id_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Game_hit_tank_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 hited_tank_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hited_tank_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Message.bulletinfo bulletinfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_bulletinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_hit_tank_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_hit_tank_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 hited_tank_id = 1;
  if (this->_internal_hited_tank_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hited_tank_id(), target);
  }

  // .Message.bulletinfo bulletinfo = 2;
  if (this->_internal_has_bulletinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::bulletinfo(this),
        _Internal::bulletinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_hit_tank_Request)
  return target;
}

size_t Game_hit_tank_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_hit_tank_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Message.bulletinfo bulletinfo = 2;
  if (this->_internal_has_bulletinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bulletinfo_);
  }

  // int32 hited_tank_id = 1;
  if (this->_internal_hited_tank_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hited_tank_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_hit_tank_Request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_hit_tank_Request*>(
      &from));
}

void Game_hit_tank_Request::MergeFrom(const Game_hit_tank_Request& from) {
  Game_hit_tank_Request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_hit_tank_Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_bulletinfo()) {
    _this->_internal_mutable_bulletinfo()->::Message::bulletinfo::MergeFrom(
        from._internal_bulletinfo());
  }
  if (from._internal_hited_tank_id() != 0) {
    _this->_internal_set_hited_tank_id(from._internal_hited_tank_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_hit_tank_Request::CopyFrom(const Game_hit_tank_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_hit_tank_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_hit_tank_Request::IsInitialized() const {
  return true;
}

void Game_hit_tank_Request::InternalSwap(Game_hit_tank_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Game_hit_tank_Request, _impl_.hited_tank_id_)
      + sizeof(Game_hit_tank_Request::_impl_.hited_tank_id_)
      - PROTOBUF_FIELD_OFFSET(Game_hit_tank_Request, _impl_.bulletinfo_)>(
          reinterpret_cast<char*>(&_impl_.bulletinfo_),
          reinterpret_cast<char*>(&other->_impl_.bulletinfo_));
}

std::string Game_hit_tank_Request::GetTypeName() const {
  return "Message.Game_hit_tank_Request";
}


// ===================================================================

class Game_tank_hited_Response::_Internal {
 public:
};

Game_tank_hited_Response::Game_tank_hited_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_tank_hited_Response)
}
Game_tank_hited_Response::Game_tank_hited_Response(const Game_tank_hited_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_tank_hited_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hited_tank_id_){}
    , decltype(_impl_.health_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.hited_tank_id_, &from._impl_.hited_tank_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.health_) -
    reinterpret_cast<char*>(&_impl_.hited_tank_id_)) + sizeof(_impl_.health_));
  // @@protoc_insertion_point(copy_constructor:Message.Game_tank_hited_Response)
}

inline void Game_tank_hited_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hited_tank_id_){0}
    , decltype(_impl_.health_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_tank_hited_Response::~Game_tank_hited_Response() {
  // @@protoc_insertion_point(destructor:Message.Game_tank_hited_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_tank_hited_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Game_tank_hited_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_tank_hited_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_tank_hited_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.hited_tank_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.health_) -
      reinterpret_cast<char*>(&_impl_.hited_tank_id_)) + sizeof(_impl_.health_));
  _internal_metadata_.Clear<std::string>();
}

const char* Game_tank_hited_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 hited_tank_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hited_tank_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 health = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.health_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_tank_hited_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_tank_hited_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 hited_tank_id = 1;
  if (this->_internal_hited_tank_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hited_tank_id(), target);
  }

  // int32 health = 2;
  if (this->_internal_health() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_health(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_tank_hited_Response)
  return target;
}

size_t Game_tank_hited_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_tank_hited_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 hited_tank_id = 1;
  if (this->_internal_hited_tank_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hited_tank_id());
  }

  // int32 health = 2;
  if (this->_internal_health() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_health());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_tank_hited_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_tank_hited_Response*>(
      &from));
}

void Game_tank_hited_Response::MergeFrom(const Game_tank_hited_Response& from) {
  Game_tank_hited_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_tank_hited_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_hited_tank_id() != 0) {
    _this->_internal_set_hited_tank_id(from._internal_hited_tank_id());
  }
  if (from._internal_health() != 0) {
    _this->_internal_set_health(from._internal_health());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_tank_hited_Response::CopyFrom(const Game_tank_hited_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_tank_hited_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_tank_hited_Response::IsInitialized() const {
  return true;
}

void Game_tank_hited_Response::InternalSwap(Game_tank_hited_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Game_tank_hited_Response, _impl_.health_)
      + sizeof(Game_tank_hited_Response::_impl_.health_)
      - PROTOBUF_FIELD_OFFSET(Game_tank_hited_Response, _impl_.hited_tank_id_)>(
          reinterpret_cast<char*>(&_impl_.hited_tank_id_),
          reinterpret_cast<char*>(&other->_impl_.hited_tank_id_));
}

std::string Game_tank_hited_Response::GetTypeName() const {
  return "Message.Game_tank_hited_Response";
}


// ===================================================================

class Game_destroyed_tank_Response::_Internal {
 public:
};

Game_destroyed_tank_Response::Game_destroyed_tank_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Message.Game_destroyed_tank_Response)
}
Game_destroyed_tank_Response::Game_destroyed_tank_Response(const Game_destroyed_tank_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Game_destroyed_tank_Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.destroyed_tank_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.destroyed_tank_id_ = from._impl_.destroyed_tank_id_;
  // @@protoc_insertion_point(copy_constructor:Message.Game_destroyed_tank_Response)
}

inline void Game_destroyed_tank_Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.destroyed_tank_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Game_destroyed_tank_Response::~Game_destroyed_tank_Response() {
  // @@protoc_insertion_point(destructor:Message.Game_destroyed_tank_Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Game_destroyed_tank_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Game_destroyed_tank_Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Game_destroyed_tank_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Message.Game_destroyed_tank_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.destroyed_tank_id_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* Game_destroyed_tank_Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 destroyed_tank_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.destroyed_tank_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Game_destroyed_tank_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message.Game_destroyed_tank_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 destroyed_tank_id = 1;
  if (this->_internal_destroyed_tank_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_destroyed_tank_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message.Game_destroyed_tank_Response)
  return target;
}

size_t Game_destroyed_tank_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Message.Game_destroyed_tank_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 destroyed_tank_id = 1;
  if (this->_internal_destroyed_tank_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_destroyed_tank_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Game_destroyed_tank_Response::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Game_destroyed_tank_Response*>(
      &from));
}

void Game_destroyed_tank_Response::MergeFrom(const Game_destroyed_tank_Response& from) {
  Game_destroyed_tank_Response* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Message.Game_destroyed_tank_Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_destroyed_tank_id() != 0) {
    _this->_internal_set_destroyed_tank_id(from._internal_destroyed_tank_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Game_destroyed_tank_Response::CopyFrom(const Game_destroyed_tank_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Message.Game_destroyed_tank_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_destroyed_tank_Response::IsInitialized() const {
  return true;
}

void Game_destroyed_tank_Response::InternalSwap(Game_destroyed_tank_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.destroyed_tank_id_, other->_impl_.destroyed_tank_id_);
}

std::string Game_destroyed_tank_Response::GetTypeName() const {
  return "Message.Game_destroyed_tank_Response";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Message
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Message::Hall_info_Response_User*
Arena::CreateMaybeMessage< ::Message::Hall_info_Response_User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Hall_info_Response_User >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Hall_info_Response_Roominfo*
Arena::CreateMaybeMessage< ::Message::Hall_info_Response_Roominfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Hall_info_Response_Roominfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Hall_info_Response*
Arena::CreateMaybeMessage< ::Message::Hall_info_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Hall_info_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Hall_Message_Request*
Arena::CreateMaybeMessage< ::Message::Hall_Message_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Hall_Message_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Hall_Message_Response*
Arena::CreateMaybeMessage< ::Message::Hall_Message_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Hall_Message_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Hall_EnterRoom_Request*
Arena::CreateMaybeMessage< ::Message::Hall_EnterRoom_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Hall_EnterRoom_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Hall_EnterRoom_Response*
Arena::CreateMaybeMessage< ::Message::Hall_EnterRoom_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Hall_EnterRoom_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Ping_info*
Arena::CreateMaybeMessage< ::Message::Ping_info >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Ping_info >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Set_User_id*
Arena::CreateMaybeMessage< ::Message::Set_User_id >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Set_User_id >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Room_info_Response_User*
Arena::CreateMaybeMessage< ::Message::Room_info_Response_User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Room_info_Response_User >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Room_info_Response*
Arena::CreateMaybeMessage< ::Message::Room_info_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Room_info_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Room_Message_Request*
Arena::CreateMaybeMessage< ::Message::Room_Message_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Room_Message_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Room_Message_Response*
Arena::CreateMaybeMessage< ::Message::Room_Message_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Room_Message_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Room_Set_tankid*
Arena::CreateMaybeMessage< ::Message::Room_Set_tankid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Room_Set_tankid >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Room_Set_tankid_Response*
Arena::CreateMaybeMessage< ::Message::Room_Set_tankid_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Room_Set_tankid_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Room_Start_Response*
Arena::CreateMaybeMessage< ::Message::Room_Start_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Room_Start_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_tankinfo_Request*
Arena::CreateMaybeMessage< ::Message::Game_tankinfo_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_tankinfo_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_tankinfo_Response_tankinfo*
Arena::CreateMaybeMessage< ::Message::Game_tankinfo_Response_tankinfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_tankinfo_Response_tankinfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_tankinfo_Response*
Arena::CreateMaybeMessage< ::Message::Game_tankinfo_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_tankinfo_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::bulletinfo*
Arena::CreateMaybeMessage< ::Message::bulletinfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::bulletinfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_bulletinfo_Request*
Arena::CreateMaybeMessage< ::Message::Game_bulletinfo_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_bulletinfo_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_bulletinfo_Response_Info*
Arena::CreateMaybeMessage< ::Message::Game_bulletinfo_Response_Info >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_bulletinfo_Response_Info >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_bulletinfo_Response*
Arena::CreateMaybeMessage< ::Message::Game_bulletinfo_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_bulletinfo_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_hit_brick_Request*
Arena::CreateMaybeMessage< ::Message::Game_hit_brick_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_hit_brick_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_brick_hited_Response*
Arena::CreateMaybeMessage< ::Message::Game_brick_hited_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_brick_hited_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_hit_tank_Request*
Arena::CreateMaybeMessage< ::Message::Game_hit_tank_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_hit_tank_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_tank_hited_Response*
Arena::CreateMaybeMessage< ::Message::Game_tank_hited_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_tank_hited_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Message::Game_destroyed_tank_Response*
Arena::CreateMaybeMessage< ::Message::Game_destroyed_tank_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Message::Game_destroyed_tank_Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
