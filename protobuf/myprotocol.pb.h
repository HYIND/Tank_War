// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: myprotocol.proto
// Protobuf C++ Version: 4.24.0-main

#ifndef GOOGLE_PROTOBUF_INCLUDED_myprotocol_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_myprotocol_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_myprotocol_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_myprotocol_2eproto {
  static const ::uint32_t offsets[];
};
namespace Message {
class Game_brick_hited_Response;
struct Game_brick_hited_ResponseDefaultTypeInternal;
extern Game_brick_hited_ResponseDefaultTypeInternal _Game_brick_hited_Response_default_instance_;
class Game_bulletinfo_Request;
struct Game_bulletinfo_RequestDefaultTypeInternal;
extern Game_bulletinfo_RequestDefaultTypeInternal _Game_bulletinfo_Request_default_instance_;
class Game_bulletinfo_Response;
struct Game_bulletinfo_ResponseDefaultTypeInternal;
extern Game_bulletinfo_ResponseDefaultTypeInternal _Game_bulletinfo_Response_default_instance_;
class Game_bulletinfo_Response_Info;
struct Game_bulletinfo_Response_InfoDefaultTypeInternal;
extern Game_bulletinfo_Response_InfoDefaultTypeInternal _Game_bulletinfo_Response_Info_default_instance_;
class Game_destroyed_tank_Response;
struct Game_destroyed_tank_ResponseDefaultTypeInternal;
extern Game_destroyed_tank_ResponseDefaultTypeInternal _Game_destroyed_tank_Response_default_instance_;
class Game_getProp_Request;
struct Game_getProp_RequestDefaultTypeInternal;
extern Game_getProp_RequestDefaultTypeInternal _Game_getProp_Request_default_instance_;
class Game_hit_brick_Request;
struct Game_hit_brick_RequestDefaultTypeInternal;
extern Game_hit_brick_RequestDefaultTypeInternal _Game_hit_brick_Request_default_instance_;
class Game_hit_tank_Request;
struct Game_hit_tank_RequestDefaultTypeInternal;
extern Game_hit_tank_RequestDefaultTypeInternal _Game_hit_tank_Request_default_instance_;
class Game_prop_Response;
struct Game_prop_ResponseDefaultTypeInternal;
extern Game_prop_ResponseDefaultTypeInternal _Game_prop_Response_default_instance_;
class Game_tank_hited_Response;
struct Game_tank_hited_ResponseDefaultTypeInternal;
extern Game_tank_hited_ResponseDefaultTypeInternal _Game_tank_hited_Response_default_instance_;
class Game_tankinfo_Request;
struct Game_tankinfo_RequestDefaultTypeInternal;
extern Game_tankinfo_RequestDefaultTypeInternal _Game_tankinfo_Request_default_instance_;
class Game_tankinfo_Response;
struct Game_tankinfo_ResponseDefaultTypeInternal;
extern Game_tankinfo_ResponseDefaultTypeInternal _Game_tankinfo_Response_default_instance_;
class Game_tankinfo_Response_tankinfo;
struct Game_tankinfo_Response_tankinfoDefaultTypeInternal;
extern Game_tankinfo_Response_tankinfoDefaultTypeInternal _Game_tankinfo_Response_tankinfo_default_instance_;
class Hall_EnterRoom_Request;
struct Hall_EnterRoom_RequestDefaultTypeInternal;
extern Hall_EnterRoom_RequestDefaultTypeInternal _Hall_EnterRoom_Request_default_instance_;
class Hall_EnterRoom_Response;
struct Hall_EnterRoom_ResponseDefaultTypeInternal;
extern Hall_EnterRoom_ResponseDefaultTypeInternal _Hall_EnterRoom_Response_default_instance_;
class Hall_Message_Request;
struct Hall_Message_RequestDefaultTypeInternal;
extern Hall_Message_RequestDefaultTypeInternal _Hall_Message_Request_default_instance_;
class Hall_Message_Response;
struct Hall_Message_ResponseDefaultTypeInternal;
extern Hall_Message_ResponseDefaultTypeInternal _Hall_Message_Response_default_instance_;
class Hall_info_Response;
struct Hall_info_ResponseDefaultTypeInternal;
extern Hall_info_ResponseDefaultTypeInternal _Hall_info_Response_default_instance_;
class Hall_info_Response_Roominfo;
struct Hall_info_Response_RoominfoDefaultTypeInternal;
extern Hall_info_Response_RoominfoDefaultTypeInternal _Hall_info_Response_Roominfo_default_instance_;
class Hall_info_Response_User;
struct Hall_info_Response_UserDefaultTypeInternal;
extern Hall_info_Response_UserDefaultTypeInternal _Hall_info_Response_User_default_instance_;
class Ping_info;
struct Ping_infoDefaultTypeInternal;
extern Ping_infoDefaultTypeInternal _Ping_info_default_instance_;
class Room_Message_Request;
struct Room_Message_RequestDefaultTypeInternal;
extern Room_Message_RequestDefaultTypeInternal _Room_Message_Request_default_instance_;
class Room_Message_Response;
struct Room_Message_ResponseDefaultTypeInternal;
extern Room_Message_ResponseDefaultTypeInternal _Room_Message_Response_default_instance_;
class Room_Set_tankid;
struct Room_Set_tankidDefaultTypeInternal;
extern Room_Set_tankidDefaultTypeInternal _Room_Set_tankid_default_instance_;
class Room_Set_tankid_Response;
struct Room_Set_tankid_ResponseDefaultTypeInternal;
extern Room_Set_tankid_ResponseDefaultTypeInternal _Room_Set_tankid_Response_default_instance_;
class Room_Start_Response;
struct Room_Start_ResponseDefaultTypeInternal;
extern Room_Start_ResponseDefaultTypeInternal _Room_Start_Response_default_instance_;
class Room_info_Response;
struct Room_info_ResponseDefaultTypeInternal;
extern Room_info_ResponseDefaultTypeInternal _Room_info_Response_default_instance_;
class Room_info_Response_User;
struct Room_info_Response_UserDefaultTypeInternal;
extern Room_info_Response_UserDefaultTypeInternal _Room_info_Response_User_default_instance_;
class Set_User_id;
struct Set_User_idDefaultTypeInternal;
extern Set_User_idDefaultTypeInternal _Set_User_id_default_instance_;
class UDP_INFO_REQ;
struct UDP_INFO_REQDefaultTypeInternal;
extern UDP_INFO_REQDefaultTypeInternal _UDP_INFO_REQ_default_instance_;
class UDP_INFO_RES;
struct UDP_INFO_RESDefaultTypeInternal;
extern UDP_INFO_RESDefaultTypeInternal _UDP_INFO_RES_default_instance_;
class bulletinfo;
struct bulletinfoDefaultTypeInternal;
extern bulletinfoDefaultTypeInternal _bulletinfo_default_instance_;
}  // namespace Message
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace Message {

// ===================================================================


// -------------------------------------------------------------------

class bulletinfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.bulletinfo) */ {
 public:
  inline bulletinfo() : bulletinfo(nullptr) {}
  ~bulletinfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR bulletinfo(::google::protobuf::internal::ConstantInitialized);

  inline bulletinfo(const bulletinfo& from)
      : bulletinfo(nullptr, from) {}
  bulletinfo(bulletinfo&& from) noexcept
    : bulletinfo() {
    *this = ::std::move(from);
  }

  inline bulletinfo& operator=(const bulletinfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline bulletinfo& operator=(bulletinfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const bulletinfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const bulletinfo* internal_default_instance() {
    return reinterpret_cast<const bulletinfo*>(
               &_bulletinfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(bulletinfo& a, bulletinfo& b) {
    a.Swap(&b);
  }
  inline void Swap(bulletinfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(bulletinfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  bulletinfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<bulletinfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const bulletinfo& from);
  void MergeFrom(const bulletinfo& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(bulletinfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.bulletinfo";
  }
  protected:
  explicit bulletinfo(::google::protobuf::Arena* arena);
  bulletinfo(::google::protobuf::Arena* arena, const bulletinfo& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationXFieldNumber = 1,
    kLocationYFieldNumber = 2,
    kRotateFieldNumber = 3,
    kBulletStyleFieldNumber = 4,
  };
  // double locationX = 1;
  void clear_locationx() ;
  double locationx() const;
  void set_locationx(double value);

  private:
  double _internal_locationx() const;
  void _internal_set_locationx(double value);

  public:
  // double locationY = 2;
  void clear_locationy() ;
  double locationy() const;
  void set_locationy(double value);

  private:
  double _internal_locationy() const;
  void _internal_set_locationy(double value);

  public:
  // double rotate = 3;
  void clear_rotate() ;
  double rotate() const;
  void set_rotate(double value);

  private:
  double _internal_rotate() const;
  void _internal_set_rotate(double value);

  public:
  // int32 bullet_style = 4;
  void clear_bullet_style() ;
  ::int32_t bullet_style() const;
  void set_bullet_style(::int32_t value);

  private:
  ::int32_t _internal_bullet_style() const;
  void _internal_set_bullet_style(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.bulletinfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double locationx_;
    double locationy_;
    double rotate_;
    ::int32_t bullet_style_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class UDP_INFO_RES final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.UDP_INFO_RES) */ {
 public:
  inline UDP_INFO_RES() : UDP_INFO_RES(nullptr) {}
  ~UDP_INFO_RES() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UDP_INFO_RES(::google::protobuf::internal::ConstantInitialized);

  inline UDP_INFO_RES(const UDP_INFO_RES& from)
      : UDP_INFO_RES(nullptr, from) {}
  UDP_INFO_RES(UDP_INFO_RES&& from) noexcept
    : UDP_INFO_RES() {
    *this = ::std::move(from);
  }

  inline UDP_INFO_RES& operator=(const UDP_INFO_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDP_INFO_RES& operator=(UDP_INFO_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UDP_INFO_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDP_INFO_RES* internal_default_instance() {
    return reinterpret_cast<const UDP_INFO_RES*>(
               &_UDP_INFO_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UDP_INFO_RES& a, UDP_INFO_RES& b) {
    a.Swap(&b);
  }
  inline void Swap(UDP_INFO_RES* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDP_INFO_RES* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDP_INFO_RES* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDP_INFO_RES>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const UDP_INFO_RES& from);
  void MergeFrom(const UDP_INFO_RES& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UDP_INFO_RES* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.UDP_INFO_RES";
  }
  protected:
  explicit UDP_INFO_RES(::google::protobuf::Arena* arena);
  UDP_INFO_RES(::google::protobuf::Arena* arena, const UDP_INFO_RES& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOKFieldNumber = 1,
  };
  // bool OK = 1;
  void clear_ok() ;
  bool ok() const;
  void set_ok(bool value);

  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Message.UDP_INFO_RES)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool ok_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class UDP_INFO_REQ final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.UDP_INFO_REQ) */ {
 public:
  inline UDP_INFO_REQ() : UDP_INFO_REQ(nullptr) {}
  ~UDP_INFO_REQ() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UDP_INFO_REQ(::google::protobuf::internal::ConstantInitialized);

  inline UDP_INFO_REQ(const UDP_INFO_REQ& from)
      : UDP_INFO_REQ(nullptr, from) {}
  UDP_INFO_REQ(UDP_INFO_REQ&& from) noexcept
    : UDP_INFO_REQ() {
    *this = ::std::move(from);
  }

  inline UDP_INFO_REQ& operator=(const UDP_INFO_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDP_INFO_REQ& operator=(UDP_INFO_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UDP_INFO_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDP_INFO_REQ* internal_default_instance() {
    return reinterpret_cast<const UDP_INFO_REQ*>(
               &_UDP_INFO_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UDP_INFO_REQ& a, UDP_INFO_REQ& b) {
    a.Swap(&b);
  }
  inline void Swap(UDP_INFO_REQ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDP_INFO_REQ* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDP_INFO_REQ* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDP_INFO_REQ>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const UDP_INFO_REQ& from);
  void MergeFrom(const UDP_INFO_REQ& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UDP_INFO_REQ* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.UDP_INFO_REQ";
  }
  protected:
  explicit UDP_INFO_REQ(::google::protobuf::Arena* arena);
  UDP_INFO_REQ(::google::protobuf::Arena* arena, const UDP_INFO_REQ& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // int32 port = 2;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.UDP_INFO_REQ)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::int32_t port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Set_User_id final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Set_User_id) */ {
 public:
  inline Set_User_id() : Set_User_id(nullptr) {}
  ~Set_User_id() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Set_User_id(::google::protobuf::internal::ConstantInitialized);

  inline Set_User_id(const Set_User_id& from)
      : Set_User_id(nullptr, from) {}
  Set_User_id(Set_User_id&& from) noexcept
    : Set_User_id() {
    *this = ::std::move(from);
  }

  inline Set_User_id& operator=(const Set_User_id& from) {
    CopyFrom(from);
    return *this;
  }
  inline Set_User_id& operator=(Set_User_id&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Set_User_id& default_instance() {
    return *internal_default_instance();
  }
  static inline const Set_User_id* internal_default_instance() {
    return reinterpret_cast<const Set_User_id*>(
               &_Set_User_id_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Set_User_id& a, Set_User_id& b) {
    a.Swap(&b);
  }
  inline void Swap(Set_User_id* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Set_User_id* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Set_User_id* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Set_User_id>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Set_User_id& from);
  void MergeFrom(const Set_User_id& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Set_User_id* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Set_User_id";
  }
  protected:
  explicit Set_User_id(::google::protobuf::Arena* arena);
  Set_User_id(::google::protobuf::Arena* arena, const Set_User_id& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:Message.Set_User_id)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Room_info_Response_User final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Room_info_Response.User) */ {
 public:
  inline Room_info_Response_User() : Room_info_Response_User(nullptr) {}
  ~Room_info_Response_User() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Room_info_Response_User(::google::protobuf::internal::ConstantInitialized);

  inline Room_info_Response_User(const Room_info_Response_User& from)
      : Room_info_Response_User(nullptr, from) {}
  Room_info_Response_User(Room_info_Response_User&& from) noexcept
    : Room_info_Response_User() {
    *this = ::std::move(from);
  }

  inline Room_info_Response_User& operator=(const Room_info_Response_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_info_Response_User& operator=(Room_info_Response_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Room_info_Response_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_info_Response_User* internal_default_instance() {
    return reinterpret_cast<const Room_info_Response_User*>(
               &_Room_info_Response_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Room_info_Response_User& a, Room_info_Response_User& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_info_Response_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_info_Response_User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_info_Response_User* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_info_Response_User>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Room_info_Response_User& from);
  void MergeFrom(const Room_info_Response_User& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Room_info_Response_User* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Room_info_Response.User";
  }
  protected:
  explicit Room_info_Response_User(::google::protobuf::Arena* arena);
  Room_info_Response_User(::google::protobuf::Arena* arena, const Room_info_Response_User& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 status = 2;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Room_info_Response.User)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Room_Start_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Room_Start_Response) */ {
 public:
  inline Room_Start_Response() : Room_Start_Response(nullptr) {}
  ~Room_Start_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Room_Start_Response(::google::protobuf::internal::ConstantInitialized);

  inline Room_Start_Response(const Room_Start_Response& from)
      : Room_Start_Response(nullptr, from) {}
  Room_Start_Response(Room_Start_Response&& from) noexcept
    : Room_Start_Response() {
    *this = ::std::move(from);
  }

  inline Room_Start_Response& operator=(const Room_Start_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Start_Response& operator=(Room_Start_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Room_Start_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Start_Response* internal_default_instance() {
    return reinterpret_cast<const Room_Start_Response*>(
               &_Room_Start_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Room_Start_Response& a, Room_Start_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Start_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Start_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Start_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Start_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Room_Start_Response& from);
  void MergeFrom(const Room_Start_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Room_Start_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Room_Start_Response";
  }
  protected:
  explicit Room_Start_Response(::google::protobuf::Arena* arena);
  Room_Start_Response(::google::protobuf::Arena* arena, const Room_Start_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // int32 result = 1;
  void clear_result() ;
  ::int32_t result() const;
  void set_result(::int32_t value);

  private:
  ::int32_t _internal_result() const;
  void _internal_set_result(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Room_Start_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Room_Set_tankid_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Room_Set_tankid_Response) */ {
 public:
  inline Room_Set_tankid_Response() : Room_Set_tankid_Response(nullptr) {}
  ~Room_Set_tankid_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Room_Set_tankid_Response(::google::protobuf::internal::ConstantInitialized);

  inline Room_Set_tankid_Response(const Room_Set_tankid_Response& from)
      : Room_Set_tankid_Response(nullptr, from) {}
  Room_Set_tankid_Response(Room_Set_tankid_Response&& from) noexcept
    : Room_Set_tankid_Response() {
    *this = ::std::move(from);
  }

  inline Room_Set_tankid_Response& operator=(const Room_Set_tankid_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Set_tankid_Response& operator=(Room_Set_tankid_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Room_Set_tankid_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Set_tankid_Response* internal_default_instance() {
    return reinterpret_cast<const Room_Set_tankid_Response*>(
               &_Room_Set_tankid_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Room_Set_tankid_Response& a, Room_Set_tankid_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Set_tankid_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Set_tankid_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Set_tankid_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Set_tankid_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Room_Set_tankid_Response& from);
  void MergeFrom(const Room_Set_tankid_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Room_Set_tankid_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Room_Set_tankid_Response";
  }
  protected:
  explicit Room_Set_tankid_Response(::google::protobuf::Arena* arena);
  Room_Set_tankid_Response(::google::protobuf::Arena* arena, const Room_Set_tankid_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Room_Set_tankid_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Room_Set_tankid final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Room_Set_tankid) */ {
 public:
  inline Room_Set_tankid() : Room_Set_tankid(nullptr) {}
  ~Room_Set_tankid() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Room_Set_tankid(::google::protobuf::internal::ConstantInitialized);

  inline Room_Set_tankid(const Room_Set_tankid& from)
      : Room_Set_tankid(nullptr, from) {}
  Room_Set_tankid(Room_Set_tankid&& from) noexcept
    : Room_Set_tankid() {
    *this = ::std::move(from);
  }

  inline Room_Set_tankid& operator=(const Room_Set_tankid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Set_tankid& operator=(Room_Set_tankid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Room_Set_tankid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Set_tankid* internal_default_instance() {
    return reinterpret_cast<const Room_Set_tankid*>(
               &_Room_Set_tankid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Room_Set_tankid& a, Room_Set_tankid& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Set_tankid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Set_tankid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Set_tankid* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Set_tankid>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Room_Set_tankid& from);
  void MergeFrom(const Room_Set_tankid& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Room_Set_tankid* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Room_Set_tankid";
  }
  protected:
  explicit Room_Set_tankid(::google::protobuf::Arena* arena);
  Room_Set_tankid(::google::protobuf::Arena* arena, const Room_Set_tankid& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Room_Set_tankid)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Room_Message_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Room_Message_Response) */ {
 public:
  inline Room_Message_Response() : Room_Message_Response(nullptr) {}
  ~Room_Message_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Room_Message_Response(::google::protobuf::internal::ConstantInitialized);

  inline Room_Message_Response(const Room_Message_Response& from)
      : Room_Message_Response(nullptr, from) {}
  Room_Message_Response(Room_Message_Response&& from) noexcept
    : Room_Message_Response() {
    *this = ::std::move(from);
  }

  inline Room_Message_Response& operator=(const Room_Message_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Message_Response& operator=(Room_Message_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Room_Message_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Message_Response* internal_default_instance() {
    return reinterpret_cast<const Room_Message_Response*>(
               &_Room_Message_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Room_Message_Response& a, Room_Message_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Message_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Message_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Message_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Message_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Room_Message_Response& from);
  void MergeFrom(const Room_Message_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Room_Message_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Room_Message_Response";
  }
  protected:
  explicit Room_Message_Response(::google::protobuf::Arena* arena);
  Room_Message_Response(::google::protobuf::Arena* arena, const Room_Message_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string content = 2;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // @@protoc_insertion_point(class_scope:Message.Room_Message_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Room_Message_Request final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Room_Message_Request) */ {
 public:
  inline Room_Message_Request() : Room_Message_Request(nullptr) {}
  ~Room_Message_Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Room_Message_Request(::google::protobuf::internal::ConstantInitialized);

  inline Room_Message_Request(const Room_Message_Request& from)
      : Room_Message_Request(nullptr, from) {}
  Room_Message_Request(Room_Message_Request&& from) noexcept
    : Room_Message_Request() {
    *this = ::std::move(from);
  }

  inline Room_Message_Request& operator=(const Room_Message_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Message_Request& operator=(Room_Message_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Room_Message_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Message_Request* internal_default_instance() {
    return reinterpret_cast<const Room_Message_Request*>(
               &_Room_Message_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Room_Message_Request& a, Room_Message_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Message_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Message_Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Message_Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Message_Request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Room_Message_Request& from);
  void MergeFrom(const Room_Message_Request& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Room_Message_Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Room_Message_Request";
  }
  protected:
  explicit Room_Message_Request(::google::protobuf::Arena* arena);
  Room_Message_Request(::google::protobuf::Arena* arena, const Room_Message_Request& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // @@protoc_insertion_point(class_scope:Message.Room_Message_Request)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr content_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Ping_info final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Ping_info) */ {
 public:
  inline Ping_info() : Ping_info(nullptr) {}
  ~Ping_info() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Ping_info(::google::protobuf::internal::ConstantInitialized);

  inline Ping_info(const Ping_info& from)
      : Ping_info(nullptr, from) {}
  Ping_info(Ping_info&& from) noexcept
    : Ping_info() {
    *this = ::std::move(from);
  }

  inline Ping_info& operator=(const Ping_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping_info& operator=(Ping_info&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Ping_info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping_info* internal_default_instance() {
    return reinterpret_cast<const Ping_info*>(
               &_Ping_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Ping_info& a, Ping_info& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping_info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping_info* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping_info* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping_info>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Ping_info& from);
  void MergeFrom(const Ping_info& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Ping_info* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Ping_info";
  }
  protected:
  explicit Ping_info(::google::protobuf::Arena* arena);
  Ping_info(::google::protobuf::Arena* arena, const Ping_info& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPingIdFieldNumber = 1,
  };
  // int32 ping_id = 1;
  void clear_ping_id() ;
  ::int32_t ping_id() const;
  void set_ping_id(::int32_t value);

  private:
  ::int32_t _internal_ping_id() const;
  void _internal_set_ping_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Ping_info)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t ping_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Hall_info_Response_User final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Hall_info_Response.User) */ {
 public:
  inline Hall_info_Response_User() : Hall_info_Response_User(nullptr) {}
  ~Hall_info_Response_User() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hall_info_Response_User(::google::protobuf::internal::ConstantInitialized);

  inline Hall_info_Response_User(const Hall_info_Response_User& from)
      : Hall_info_Response_User(nullptr, from) {}
  Hall_info_Response_User(Hall_info_Response_User&& from) noexcept
    : Hall_info_Response_User() {
    *this = ::std::move(from);
  }

  inline Hall_info_Response_User& operator=(const Hall_info_Response_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_info_Response_User& operator=(Hall_info_Response_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Hall_info_Response_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_info_Response_User* internal_default_instance() {
    return reinterpret_cast<const Hall_info_Response_User*>(
               &_Hall_info_Response_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Hall_info_Response_User& a, Hall_info_Response_User& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_info_Response_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_info_Response_User* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_info_Response_User* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_info_Response_User>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Hall_info_Response_User& from);
  void MergeFrom(const Hall_info_Response_User& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hall_info_Response_User* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Hall_info_Response.User";
  }
  protected:
  explicit Hall_info_Response_User(::google::protobuf::Arena* arena);
  Hall_info_Response_User(::google::protobuf::Arena* arena, const Hall_info_Response_User& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:Message.Hall_info_Response.User)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Hall_info_Response_Roominfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Hall_info_Response.Roominfo) */ {
 public:
  inline Hall_info_Response_Roominfo() : Hall_info_Response_Roominfo(nullptr) {}
  ~Hall_info_Response_Roominfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hall_info_Response_Roominfo(::google::protobuf::internal::ConstantInitialized);

  inline Hall_info_Response_Roominfo(const Hall_info_Response_Roominfo& from)
      : Hall_info_Response_Roominfo(nullptr, from) {}
  Hall_info_Response_Roominfo(Hall_info_Response_Roominfo&& from) noexcept
    : Hall_info_Response_Roominfo() {
    *this = ::std::move(from);
  }

  inline Hall_info_Response_Roominfo& operator=(const Hall_info_Response_Roominfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_info_Response_Roominfo& operator=(Hall_info_Response_Roominfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Hall_info_Response_Roominfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_info_Response_Roominfo* internal_default_instance() {
    return reinterpret_cast<const Hall_info_Response_Roominfo*>(
               &_Hall_info_Response_Roominfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Hall_info_Response_Roominfo& a, Hall_info_Response_Roominfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_info_Response_Roominfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_info_Response_Roominfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_info_Response_Roominfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_info_Response_Roominfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Hall_info_Response_Roominfo& from);
  void MergeFrom(const Hall_info_Response_Roominfo& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hall_info_Response_Roominfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Hall_info_Response.Roominfo";
  }
  protected:
  explicit Hall_info_Response_Roominfo(::google::protobuf::Arena* arena);
  Hall_info_Response_Roominfo(::google::protobuf::Arena* arena, const Hall_info_Response_Roominfo& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostNameFieldNumber = 2,
    kRoomIdFieldNumber = 1,
  };
  // string host_name = 2;
  void clear_host_name() ;
  const std::string& host_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host_name(Arg_&& arg, Args_... args);
  std::string* mutable_host_name();
  PROTOBUF_NODISCARD std::string* release_host_name();
  void set_allocated_host_name(std::string* value);

  private:
  const std::string& _internal_host_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_name(
      const std::string& value);
  std::string* _internal_mutable_host_name();

  public:
  // int32 room_id = 1;
  void clear_room_id() ;
  ::int32_t room_id() const;
  void set_room_id(::int32_t value);

  private:
  ::int32_t _internal_room_id() const;
  void _internal_set_room_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Hall_info_Response.Roominfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr host_name_;
    ::int32_t room_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Hall_Message_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Hall_Message_Response) */ {
 public:
  inline Hall_Message_Response() : Hall_Message_Response(nullptr) {}
  ~Hall_Message_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hall_Message_Response(::google::protobuf::internal::ConstantInitialized);

  inline Hall_Message_Response(const Hall_Message_Response& from)
      : Hall_Message_Response(nullptr, from) {}
  Hall_Message_Response(Hall_Message_Response&& from) noexcept
    : Hall_Message_Response() {
    *this = ::std::move(from);
  }

  inline Hall_Message_Response& operator=(const Hall_Message_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_Message_Response& operator=(Hall_Message_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Hall_Message_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_Message_Response* internal_default_instance() {
    return reinterpret_cast<const Hall_Message_Response*>(
               &_Hall_Message_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Hall_Message_Response& a, Hall_Message_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_Message_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_Message_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_Message_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_Message_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Hall_Message_Response& from);
  void MergeFrom(const Hall_Message_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hall_Message_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Hall_Message_Response";
  }
  protected:
  explicit Hall_Message_Response(::google::protobuf::Arena* arena);
  Hall_Message_Response(::google::protobuf::Arena* arena, const Hall_Message_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string content = 2;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // @@protoc_insertion_point(class_scope:Message.Hall_Message_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Hall_Message_Request final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Hall_Message_Request) */ {
 public:
  inline Hall_Message_Request() : Hall_Message_Request(nullptr) {}
  ~Hall_Message_Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hall_Message_Request(::google::protobuf::internal::ConstantInitialized);

  inline Hall_Message_Request(const Hall_Message_Request& from)
      : Hall_Message_Request(nullptr, from) {}
  Hall_Message_Request(Hall_Message_Request&& from) noexcept
    : Hall_Message_Request() {
    *this = ::std::move(from);
  }

  inline Hall_Message_Request& operator=(const Hall_Message_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_Message_Request& operator=(Hall_Message_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Hall_Message_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_Message_Request* internal_default_instance() {
    return reinterpret_cast<const Hall_Message_Request*>(
               &_Hall_Message_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Hall_Message_Request& a, Hall_Message_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_Message_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_Message_Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_Message_Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_Message_Request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Hall_Message_Request& from);
  void MergeFrom(const Hall_Message_Request& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hall_Message_Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Hall_Message_Request";
  }
  protected:
  explicit Hall_Message_Request(::google::protobuf::Arena* arena);
  Hall_Message_Request(::google::protobuf::Arena* arena, const Hall_Message_Request& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // @@protoc_insertion_point(class_scope:Message.Hall_Message_Request)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr content_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Hall_EnterRoom_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Hall_EnterRoom_Response) */ {
 public:
  inline Hall_EnterRoom_Response() : Hall_EnterRoom_Response(nullptr) {}
  ~Hall_EnterRoom_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hall_EnterRoom_Response(::google::protobuf::internal::ConstantInitialized);

  inline Hall_EnterRoom_Response(const Hall_EnterRoom_Response& from)
      : Hall_EnterRoom_Response(nullptr, from) {}
  Hall_EnterRoom_Response(Hall_EnterRoom_Response&& from) noexcept
    : Hall_EnterRoom_Response() {
    *this = ::std::move(from);
  }

  inline Hall_EnterRoom_Response& operator=(const Hall_EnterRoom_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_EnterRoom_Response& operator=(Hall_EnterRoom_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Hall_EnterRoom_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_EnterRoom_Response* internal_default_instance() {
    return reinterpret_cast<const Hall_EnterRoom_Response*>(
               &_Hall_EnterRoom_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Hall_EnterRoom_Response& a, Hall_EnterRoom_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_EnterRoom_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_EnterRoom_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_EnterRoom_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_EnterRoom_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Hall_EnterRoom_Response& from);
  void MergeFrom(const Hall_EnterRoom_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hall_EnterRoom_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Hall_EnterRoom_Response";
  }
  protected:
  explicit Hall_EnterRoom_Response(::google::protobuf::Arena* arena);
  Hall_EnterRoom_Response(::google::protobuf::Arena* arena, const Hall_EnterRoom_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // int32 room_id = 1;
  void clear_room_id() ;
  ::int32_t room_id() const;
  void set_room_id(::int32_t value);

  private:
  ::int32_t _internal_room_id() const;
  void _internal_set_room_id(::int32_t value);

  public:
  // int32 result = 2;
  void clear_result() ;
  ::int32_t result() const;
  void set_result(::int32_t value);

  private:
  ::int32_t _internal_result() const;
  void _internal_set_result(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Hall_EnterRoom_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t room_id_;
    ::int32_t result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Hall_EnterRoom_Request final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Hall_EnterRoom_Request) */ {
 public:
  inline Hall_EnterRoom_Request() : Hall_EnterRoom_Request(nullptr) {}
  ~Hall_EnterRoom_Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hall_EnterRoom_Request(::google::protobuf::internal::ConstantInitialized);

  inline Hall_EnterRoom_Request(const Hall_EnterRoom_Request& from)
      : Hall_EnterRoom_Request(nullptr, from) {}
  Hall_EnterRoom_Request(Hall_EnterRoom_Request&& from) noexcept
    : Hall_EnterRoom_Request() {
    *this = ::std::move(from);
  }

  inline Hall_EnterRoom_Request& operator=(const Hall_EnterRoom_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_EnterRoom_Request& operator=(Hall_EnterRoom_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Hall_EnterRoom_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_EnterRoom_Request* internal_default_instance() {
    return reinterpret_cast<const Hall_EnterRoom_Request*>(
               &_Hall_EnterRoom_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Hall_EnterRoom_Request& a, Hall_EnterRoom_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_EnterRoom_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_EnterRoom_Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_EnterRoom_Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_EnterRoom_Request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Hall_EnterRoom_Request& from);
  void MergeFrom(const Hall_EnterRoom_Request& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hall_EnterRoom_Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Hall_EnterRoom_Request";
  }
  protected:
  explicit Hall_EnterRoom_Request(::google::protobuf::Arena* arena);
  Hall_EnterRoom_Request(::google::protobuf::Arena* arena, const Hall_EnterRoom_Request& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // int32 room_id = 1;
  void clear_room_id() ;
  ::int32_t room_id() const;
  void set_room_id(::int32_t value);

  private:
  ::int32_t _internal_room_id() const;
  void _internal_set_room_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Hall_EnterRoom_Request)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t room_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_tankinfo_Request final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_tankinfo_Request) */ {
 public:
  inline Game_tankinfo_Request() : Game_tankinfo_Request(nullptr) {}
  ~Game_tankinfo_Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_tankinfo_Request(::google::protobuf::internal::ConstantInitialized);

  inline Game_tankinfo_Request(const Game_tankinfo_Request& from)
      : Game_tankinfo_Request(nullptr, from) {}
  Game_tankinfo_Request(Game_tankinfo_Request&& from) noexcept
    : Game_tankinfo_Request() {
    *this = ::std::move(from);
  }

  inline Game_tankinfo_Request& operator=(const Game_tankinfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_tankinfo_Request& operator=(Game_tankinfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_tankinfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_tankinfo_Request* internal_default_instance() {
    return reinterpret_cast<const Game_tankinfo_Request*>(
               &_Game_tankinfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Game_tankinfo_Request& a, Game_tankinfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_tankinfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_tankinfo_Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_tankinfo_Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_tankinfo_Request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_tankinfo_Request& from);
  void MergeFrom(const Game_tankinfo_Request& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_tankinfo_Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_tankinfo_Request";
  }
  protected:
  explicit Game_tankinfo_Request(::google::protobuf::Arena* arena);
  Game_tankinfo_Request(::google::protobuf::Arena* arena, const Game_tankinfo_Request& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationXFieldNumber = 1,
    kLocationYFieldNumber = 2,
    kRotateFieldNumber = 3,
    kTankStyleFieldNumber = 4,
  };
  // double locationX = 1;
  void clear_locationx() ;
  double locationx() const;
  void set_locationx(double value);

  private:
  double _internal_locationx() const;
  void _internal_set_locationx(double value);

  public:
  // double locationY = 2;
  void clear_locationy() ;
  double locationy() const;
  void set_locationy(double value);

  private:
  double _internal_locationy() const;
  void _internal_set_locationy(double value);

  public:
  // double rotate = 3;
  void clear_rotate() ;
  double rotate() const;
  void set_rotate(double value);

  private:
  double _internal_rotate() const;
  void _internal_set_rotate(double value);

  public:
  // int32 tank_style = 4;
  void clear_tank_style() ;
  ::int32_t tank_style() const;
  void set_tank_style(::int32_t value);

  private:
  ::int32_t _internal_tank_style() const;
  void _internal_set_tank_style(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_tankinfo_Request)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double locationx_;
    double locationy_;
    double rotate_;
    ::int32_t tank_style_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_tank_hited_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_tank_hited_Response) */ {
 public:
  inline Game_tank_hited_Response() : Game_tank_hited_Response(nullptr) {}
  ~Game_tank_hited_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_tank_hited_Response(::google::protobuf::internal::ConstantInitialized);

  inline Game_tank_hited_Response(const Game_tank_hited_Response& from)
      : Game_tank_hited_Response(nullptr, from) {}
  Game_tank_hited_Response(Game_tank_hited_Response&& from) noexcept
    : Game_tank_hited_Response() {
    *this = ::std::move(from);
  }

  inline Game_tank_hited_Response& operator=(const Game_tank_hited_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_tank_hited_Response& operator=(Game_tank_hited_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_tank_hited_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_tank_hited_Response* internal_default_instance() {
    return reinterpret_cast<const Game_tank_hited_Response*>(
               &_Game_tank_hited_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Game_tank_hited_Response& a, Game_tank_hited_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_tank_hited_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_tank_hited_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_tank_hited_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_tank_hited_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_tank_hited_Response& from);
  void MergeFrom(const Game_tank_hited_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_tank_hited_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_tank_hited_Response";
  }
  protected:
  explicit Game_tank_hited_Response(::google::protobuf::Arena* arena);
  Game_tank_hited_Response(::google::protobuf::Arena* arena, const Game_tank_hited_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHitedTankIdFieldNumber = 1,
    kHealthFieldNumber = 2,
  };
  // int32 hited_tank_id = 1;
  void clear_hited_tank_id() ;
  ::int32_t hited_tank_id() const;
  void set_hited_tank_id(::int32_t value);

  private:
  ::int32_t _internal_hited_tank_id() const;
  void _internal_set_hited_tank_id(::int32_t value);

  public:
  // int32 health = 2;
  void clear_health() ;
  ::int32_t health() const;
  void set_health(::int32_t value);

  private:
  ::int32_t _internal_health() const;
  void _internal_set_health(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_tank_hited_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t hited_tank_id_;
    ::int32_t health_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_prop_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_prop_Response) */ {
 public:
  inline Game_prop_Response() : Game_prop_Response(nullptr) {}
  ~Game_prop_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_prop_Response(::google::protobuf::internal::ConstantInitialized);

  inline Game_prop_Response(const Game_prop_Response& from)
      : Game_prop_Response(nullptr, from) {}
  Game_prop_Response(Game_prop_Response&& from) noexcept
    : Game_prop_Response() {
    *this = ::std::move(from);
  }

  inline Game_prop_Response& operator=(const Game_prop_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_prop_Response& operator=(Game_prop_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_prop_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_prop_Response* internal_default_instance() {
    return reinterpret_cast<const Game_prop_Response*>(
               &_Game_prop_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Game_prop_Response& a, Game_prop_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_prop_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_prop_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_prop_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_prop_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_prop_Response& from);
  void MergeFrom(const Game_prop_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_prop_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_prop_Response";
  }
  protected:
  explicit Game_prop_Response(::google::protobuf::Arena* arena);
  Game_prop_Response(::google::protobuf::Arena* arena, const Game_prop_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropIdFieldNumber = 1,
    kTankIdFieldNumber = 2,
  };
  // int32 prop_id = 1;
  void clear_prop_id() ;
  ::int32_t prop_id() const;
  void set_prop_id(::int32_t value);

  private:
  ::int32_t _internal_prop_id() const;
  void _internal_set_prop_id(::int32_t value);

  public:
  // int32 tank_id = 2;
  void clear_tank_id() ;
  ::int32_t tank_id() const;
  void set_tank_id(::int32_t value);

  private:
  ::int32_t _internal_tank_id() const;
  void _internal_set_tank_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_prop_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t prop_id_;
    ::int32_t tank_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_getProp_Request final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_getProp_Request) */ {
 public:
  inline Game_getProp_Request() : Game_getProp_Request(nullptr) {}
  ~Game_getProp_Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_getProp_Request(::google::protobuf::internal::ConstantInitialized);

  inline Game_getProp_Request(const Game_getProp_Request& from)
      : Game_getProp_Request(nullptr, from) {}
  Game_getProp_Request(Game_getProp_Request&& from) noexcept
    : Game_getProp_Request() {
    *this = ::std::move(from);
  }

  inline Game_getProp_Request& operator=(const Game_getProp_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_getProp_Request& operator=(Game_getProp_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_getProp_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_getProp_Request* internal_default_instance() {
    return reinterpret_cast<const Game_getProp_Request*>(
               &_Game_getProp_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Game_getProp_Request& a, Game_getProp_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_getProp_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_getProp_Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_getProp_Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_getProp_Request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_getProp_Request& from);
  void MergeFrom(const Game_getProp_Request& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_getProp_Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_getProp_Request";
  }
  protected:
  explicit Game_getProp_Request(::google::protobuf::Arena* arena);
  Game_getProp_Request(::google::protobuf::Arena* arena, const Game_getProp_Request& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropIdFieldNumber = 1,
  };
  // int32 prop_id = 1;
  void clear_prop_id() ;
  ::int32_t prop_id() const;
  void set_prop_id(::int32_t value);

  private:
  ::int32_t _internal_prop_id() const;
  void _internal_set_prop_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_getProp_Request)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t prop_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_destroyed_tank_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_destroyed_tank_Response) */ {
 public:
  inline Game_destroyed_tank_Response() : Game_destroyed_tank_Response(nullptr) {}
  ~Game_destroyed_tank_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_destroyed_tank_Response(::google::protobuf::internal::ConstantInitialized);

  inline Game_destroyed_tank_Response(const Game_destroyed_tank_Response& from)
      : Game_destroyed_tank_Response(nullptr, from) {}
  Game_destroyed_tank_Response(Game_destroyed_tank_Response&& from) noexcept
    : Game_destroyed_tank_Response() {
    *this = ::std::move(from);
  }

  inline Game_destroyed_tank_Response& operator=(const Game_destroyed_tank_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_destroyed_tank_Response& operator=(Game_destroyed_tank_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_destroyed_tank_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_destroyed_tank_Response* internal_default_instance() {
    return reinterpret_cast<const Game_destroyed_tank_Response*>(
               &_Game_destroyed_tank_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Game_destroyed_tank_Response& a, Game_destroyed_tank_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_destroyed_tank_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_destroyed_tank_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_destroyed_tank_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_destroyed_tank_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_destroyed_tank_Response& from);
  void MergeFrom(const Game_destroyed_tank_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_destroyed_tank_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_destroyed_tank_Response";
  }
  protected:
  explicit Game_destroyed_tank_Response(::google::protobuf::Arena* arena);
  Game_destroyed_tank_Response(::google::protobuf::Arena* arena, const Game_destroyed_tank_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestroyedTankIdFieldNumber = 1,
  };
  // int32 destroyed_tank_id = 1;
  void clear_destroyed_tank_id() ;
  ::int32_t destroyed_tank_id() const;
  void set_destroyed_tank_id(::int32_t value);

  private:
  ::int32_t _internal_destroyed_tank_id() const;
  void _internal_set_destroyed_tank_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_destroyed_tank_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t destroyed_tank_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_brick_hited_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_brick_hited_Response) */ {
 public:
  inline Game_brick_hited_Response() : Game_brick_hited_Response(nullptr) {}
  ~Game_brick_hited_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_brick_hited_Response(::google::protobuf::internal::ConstantInitialized);

  inline Game_brick_hited_Response(const Game_brick_hited_Response& from)
      : Game_brick_hited_Response(nullptr, from) {}
  Game_brick_hited_Response(Game_brick_hited_Response&& from) noexcept
    : Game_brick_hited_Response() {
    *this = ::std::move(from);
  }

  inline Game_brick_hited_Response& operator=(const Game_brick_hited_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_brick_hited_Response& operator=(Game_brick_hited_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_brick_hited_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_brick_hited_Response* internal_default_instance() {
    return reinterpret_cast<const Game_brick_hited_Response*>(
               &_Game_brick_hited_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Game_brick_hited_Response& a, Game_brick_hited_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_brick_hited_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_brick_hited_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_brick_hited_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_brick_hited_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_brick_hited_Response& from);
  void MergeFrom(const Game_brick_hited_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_brick_hited_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_brick_hited_Response";
  }
  protected:
  explicit Game_brick_hited_Response(::google::protobuf::Arena* arena);
  Game_brick_hited_Response(::google::protobuf::Arena* arena, const Game_brick_hited_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHitedBrickIdFieldNumber = 1,
    kHealthFieldNumber = 2,
  };
  // int32 hited_brick_id = 1;
  void clear_hited_brick_id() ;
  ::int32_t hited_brick_id() const;
  void set_hited_brick_id(::int32_t value);

  private:
  ::int32_t _internal_hited_brick_id() const;
  void _internal_set_hited_brick_id(::int32_t value);

  public:
  // int32 health = 2;
  void clear_health() ;
  ::int32_t health() const;
  void set_health(::int32_t value);

  private:
  ::int32_t _internal_health() const;
  void _internal_set_health(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_brick_hited_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t hited_brick_id_;
    ::int32_t health_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Room_info_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Room_info_Response) */ {
 public:
  inline Room_info_Response() : Room_info_Response(nullptr) {}
  ~Room_info_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Room_info_Response(::google::protobuf::internal::ConstantInitialized);

  inline Room_info_Response(const Room_info_Response& from)
      : Room_info_Response(nullptr, from) {}
  Room_info_Response(Room_info_Response&& from) noexcept
    : Room_info_Response() {
    *this = ::std::move(from);
  }

  inline Room_info_Response& operator=(const Room_info_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_info_Response& operator=(Room_info_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Room_info_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_info_Response* internal_default_instance() {
    return reinterpret_cast<const Room_info_Response*>(
               &_Room_info_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Room_info_Response& a, Room_info_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_info_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_info_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_info_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_info_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Room_info_Response& from);
  void MergeFrom(const Room_info_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Room_info_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Room_info_Response";
  }
  protected:
  explicit Room_info_Response(::google::protobuf::Arena* arena);
  Room_info_Response(::google::protobuf::Arena* arena, const Room_info_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  using User = Room_info_Response_User;

  // accessors -------------------------------------------------------

  enum : int {
    kUserinfoFieldNumber = 1,
  };
  // repeated .Message.Room_info_Response.User userinfo = 1;
  int userinfo_size() const;
  private:
  int _internal_userinfo_size() const;

  public:
  void clear_userinfo() ;
  ::Message::Room_info_Response_User* mutable_userinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::Room_info_Response_User >*
      mutable_userinfo();
  private:
  const ::google::protobuf::RepeatedPtrField<::Message::Room_info_Response_User>& _internal_userinfo() const;
  ::google::protobuf::RepeatedPtrField<::Message::Room_info_Response_User>* _internal_mutable_userinfo();
  public:
  const ::Message::Room_info_Response_User& userinfo(int index) const;
  ::Message::Room_info_Response_User* add_userinfo();
  const ::google::protobuf::RepeatedPtrField< ::Message::Room_info_Response_User >&
      userinfo() const;
  // @@protoc_insertion_point(class_scope:Message.Room_info_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Message::Room_info_Response_User > userinfo_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Hall_info_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Hall_info_Response) */ {
 public:
  inline Hall_info_Response() : Hall_info_Response(nullptr) {}
  ~Hall_info_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hall_info_Response(::google::protobuf::internal::ConstantInitialized);

  inline Hall_info_Response(const Hall_info_Response& from)
      : Hall_info_Response(nullptr, from) {}
  Hall_info_Response(Hall_info_Response&& from) noexcept
    : Hall_info_Response() {
    *this = ::std::move(from);
  }

  inline Hall_info_Response& operator=(const Hall_info_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_info_Response& operator=(Hall_info_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Hall_info_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_info_Response* internal_default_instance() {
    return reinterpret_cast<const Hall_info_Response*>(
               &_Hall_info_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Hall_info_Response& a, Hall_info_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_info_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_info_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_info_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_info_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Hall_info_Response& from);
  void MergeFrom(const Hall_info_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hall_info_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Hall_info_Response";
  }
  protected:
  explicit Hall_info_Response(::google::protobuf::Arena* arena);
  Hall_info_Response(::google::protobuf::Arena* arena, const Hall_info_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  using User = Hall_info_Response_User;
  using Roominfo = Hall_info_Response_Roominfo;

  // accessors -------------------------------------------------------

  enum : int {
    kUserinfoFieldNumber = 1,
    kRoominfoFieldNumber = 2,
  };
  // repeated .Message.Hall_info_Response.User userinfo = 1;
  int userinfo_size() const;
  private:
  int _internal_userinfo_size() const;

  public:
  void clear_userinfo() ;
  ::Message::Hall_info_Response_User* mutable_userinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::Hall_info_Response_User >*
      mutable_userinfo();
  private:
  const ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_User>& _internal_userinfo() const;
  ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_User>* _internal_mutable_userinfo();
  public:
  const ::Message::Hall_info_Response_User& userinfo(int index) const;
  ::Message::Hall_info_Response_User* add_userinfo();
  const ::google::protobuf::RepeatedPtrField< ::Message::Hall_info_Response_User >&
      userinfo() const;
  // repeated .Message.Hall_info_Response.Roominfo roominfo = 2;
  int roominfo_size() const;
  private:
  int _internal_roominfo_size() const;

  public:
  void clear_roominfo() ;
  ::Message::Hall_info_Response_Roominfo* mutable_roominfo(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::Hall_info_Response_Roominfo >*
      mutable_roominfo();
  private:
  const ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_Roominfo>& _internal_roominfo() const;
  ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_Roominfo>* _internal_mutable_roominfo();
  public:
  const ::Message::Hall_info_Response_Roominfo& roominfo(int index) const;
  ::Message::Hall_info_Response_Roominfo* add_roominfo();
  const ::google::protobuf::RepeatedPtrField< ::Message::Hall_info_Response_Roominfo >&
      roominfo() const;
  // @@protoc_insertion_point(class_scope:Message.Hall_info_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Message::Hall_info_Response_User > userinfo_;
    ::google::protobuf::RepeatedPtrField< ::Message::Hall_info_Response_Roominfo > roominfo_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_tankinfo_Response_tankinfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_tankinfo_Response.tankinfo) */ {
 public:
  inline Game_tankinfo_Response_tankinfo() : Game_tankinfo_Response_tankinfo(nullptr) {}
  ~Game_tankinfo_Response_tankinfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_tankinfo_Response_tankinfo(::google::protobuf::internal::ConstantInitialized);

  inline Game_tankinfo_Response_tankinfo(const Game_tankinfo_Response_tankinfo& from)
      : Game_tankinfo_Response_tankinfo(nullptr, from) {}
  Game_tankinfo_Response_tankinfo(Game_tankinfo_Response_tankinfo&& from) noexcept
    : Game_tankinfo_Response_tankinfo() {
    *this = ::std::move(from);
  }

  inline Game_tankinfo_Response_tankinfo& operator=(const Game_tankinfo_Response_tankinfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_tankinfo_Response_tankinfo& operator=(Game_tankinfo_Response_tankinfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_tankinfo_Response_tankinfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_tankinfo_Response_tankinfo* internal_default_instance() {
    return reinterpret_cast<const Game_tankinfo_Response_tankinfo*>(
               &_Game_tankinfo_Response_tankinfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Game_tankinfo_Response_tankinfo& a, Game_tankinfo_Response_tankinfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_tankinfo_Response_tankinfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_tankinfo_Response_tankinfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_tankinfo_Response_tankinfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_tankinfo_Response_tankinfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_tankinfo_Response_tankinfo& from);
  void MergeFrom(const Game_tankinfo_Response_tankinfo& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_tankinfo_Response_tankinfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_tankinfo_Response.tankinfo";
  }
  protected:
  explicit Game_tankinfo_Response_tankinfo(::google::protobuf::Arena* arena);
  Game_tankinfo_Response_tankinfo(::google::protobuf::Arena* arena, const Game_tankinfo_Response_tankinfo& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTankinfoFieldNumber = 2,
    kIdFieldNumber = 1,
    kHealthFieldNumber = 3,
  };
  // .Message.Game_tankinfo_Request tankinfo = 2;
  bool has_tankinfo() const;
  void clear_tankinfo() ;
  const ::Message::Game_tankinfo_Request& tankinfo() const;
  PROTOBUF_NODISCARD ::Message::Game_tankinfo_Request* release_tankinfo();
  ::Message::Game_tankinfo_Request* mutable_tankinfo();
  void set_allocated_tankinfo(::Message::Game_tankinfo_Request* value);
  void unsafe_arena_set_allocated_tankinfo(::Message::Game_tankinfo_Request* value);
  ::Message::Game_tankinfo_Request* unsafe_arena_release_tankinfo();

  private:
  const ::Message::Game_tankinfo_Request& _internal_tankinfo() const;
  ::Message::Game_tankinfo_Request* _internal_mutable_tankinfo();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 health = 3;
  void clear_health() ;
  ::int32_t health() const;
  void set_health(::int32_t value);

  private:
  ::int32_t _internal_health() const;
  void _internal_set_health(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_tankinfo_Response.tankinfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Message::Game_tankinfo_Request* tankinfo_;
    ::int32_t id_;
    ::int32_t health_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_hit_tank_Request final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_hit_tank_Request) */ {
 public:
  inline Game_hit_tank_Request() : Game_hit_tank_Request(nullptr) {}
  ~Game_hit_tank_Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_hit_tank_Request(::google::protobuf::internal::ConstantInitialized);

  inline Game_hit_tank_Request(const Game_hit_tank_Request& from)
      : Game_hit_tank_Request(nullptr, from) {}
  Game_hit_tank_Request(Game_hit_tank_Request&& from) noexcept
    : Game_hit_tank_Request() {
    *this = ::std::move(from);
  }

  inline Game_hit_tank_Request& operator=(const Game_hit_tank_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_hit_tank_Request& operator=(Game_hit_tank_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_hit_tank_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_hit_tank_Request* internal_default_instance() {
    return reinterpret_cast<const Game_hit_tank_Request*>(
               &_Game_hit_tank_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Game_hit_tank_Request& a, Game_hit_tank_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_hit_tank_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_hit_tank_Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_hit_tank_Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_hit_tank_Request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_hit_tank_Request& from);
  void MergeFrom(const Game_hit_tank_Request& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_hit_tank_Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_hit_tank_Request";
  }
  protected:
  explicit Game_hit_tank_Request(::google::protobuf::Arena* arena);
  Game_hit_tank_Request(::google::protobuf::Arena* arena, const Game_hit_tank_Request& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulletinfoFieldNumber = 2,
    kHitedTankIdFieldNumber = 1,
  };
  // .Message.bulletinfo bulletinfo = 2;
  bool has_bulletinfo() const;
  void clear_bulletinfo() ;
  const ::Message::bulletinfo& bulletinfo() const;
  PROTOBUF_NODISCARD ::Message::bulletinfo* release_bulletinfo();
  ::Message::bulletinfo* mutable_bulletinfo();
  void set_allocated_bulletinfo(::Message::bulletinfo* value);
  void unsafe_arena_set_allocated_bulletinfo(::Message::bulletinfo* value);
  ::Message::bulletinfo* unsafe_arena_release_bulletinfo();

  private:
  const ::Message::bulletinfo& _internal_bulletinfo() const;
  ::Message::bulletinfo* _internal_mutable_bulletinfo();

  public:
  // int32 hited_tank_id = 1;
  void clear_hited_tank_id() ;
  ::int32_t hited_tank_id() const;
  void set_hited_tank_id(::int32_t value);

  private:
  ::int32_t _internal_hited_tank_id() const;
  void _internal_set_hited_tank_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_hit_tank_Request)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Message::bulletinfo* bulletinfo_;
    ::int32_t hited_tank_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_hit_brick_Request final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_hit_brick_Request) */ {
 public:
  inline Game_hit_brick_Request() : Game_hit_brick_Request(nullptr) {}
  ~Game_hit_brick_Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_hit_brick_Request(::google::protobuf::internal::ConstantInitialized);

  inline Game_hit_brick_Request(const Game_hit_brick_Request& from)
      : Game_hit_brick_Request(nullptr, from) {}
  Game_hit_brick_Request(Game_hit_brick_Request&& from) noexcept
    : Game_hit_brick_Request() {
    *this = ::std::move(from);
  }

  inline Game_hit_brick_Request& operator=(const Game_hit_brick_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_hit_brick_Request& operator=(Game_hit_brick_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_hit_brick_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_hit_brick_Request* internal_default_instance() {
    return reinterpret_cast<const Game_hit_brick_Request*>(
               &_Game_hit_brick_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Game_hit_brick_Request& a, Game_hit_brick_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_hit_brick_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_hit_brick_Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_hit_brick_Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_hit_brick_Request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_hit_brick_Request& from);
  void MergeFrom(const Game_hit_brick_Request& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_hit_brick_Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_hit_brick_Request";
  }
  protected:
  explicit Game_hit_brick_Request(::google::protobuf::Arena* arena);
  Game_hit_brick_Request(::google::protobuf::Arena* arena, const Game_hit_brick_Request& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulletinfoFieldNumber = 2,
    kHitedBrickIdFieldNumber = 1,
  };
  // .Message.bulletinfo bulletinfo = 2;
  bool has_bulletinfo() const;
  void clear_bulletinfo() ;
  const ::Message::bulletinfo& bulletinfo() const;
  PROTOBUF_NODISCARD ::Message::bulletinfo* release_bulletinfo();
  ::Message::bulletinfo* mutable_bulletinfo();
  void set_allocated_bulletinfo(::Message::bulletinfo* value);
  void unsafe_arena_set_allocated_bulletinfo(::Message::bulletinfo* value);
  ::Message::bulletinfo* unsafe_arena_release_bulletinfo();

  private:
  const ::Message::bulletinfo& _internal_bulletinfo() const;
  ::Message::bulletinfo* _internal_mutable_bulletinfo();

  public:
  // int32 hited_brick_id = 1;
  void clear_hited_brick_id() ;
  ::int32_t hited_brick_id() const;
  void set_hited_brick_id(::int32_t value);

  private:
  ::int32_t _internal_hited_brick_id() const;
  void _internal_set_hited_brick_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_hit_brick_Request)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Message::bulletinfo* bulletinfo_;
    ::int32_t hited_brick_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_bulletinfo_Response_Info final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_bulletinfo_Response.Info) */ {
 public:
  inline Game_bulletinfo_Response_Info() : Game_bulletinfo_Response_Info(nullptr) {}
  ~Game_bulletinfo_Response_Info() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_bulletinfo_Response_Info(::google::protobuf::internal::ConstantInitialized);

  inline Game_bulletinfo_Response_Info(const Game_bulletinfo_Response_Info& from)
      : Game_bulletinfo_Response_Info(nullptr, from) {}
  Game_bulletinfo_Response_Info(Game_bulletinfo_Response_Info&& from) noexcept
    : Game_bulletinfo_Response_Info() {
    *this = ::std::move(from);
  }

  inline Game_bulletinfo_Response_Info& operator=(const Game_bulletinfo_Response_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_bulletinfo_Response_Info& operator=(Game_bulletinfo_Response_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_bulletinfo_Response_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_bulletinfo_Response_Info* internal_default_instance() {
    return reinterpret_cast<const Game_bulletinfo_Response_Info*>(
               &_Game_bulletinfo_Response_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Game_bulletinfo_Response_Info& a, Game_bulletinfo_Response_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_bulletinfo_Response_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_bulletinfo_Response_Info* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_bulletinfo_Response_Info* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_bulletinfo_Response_Info>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_bulletinfo_Response_Info& from);
  void MergeFrom(const Game_bulletinfo_Response_Info& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_bulletinfo_Response_Info* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_bulletinfo_Response.Info";
  }
  protected:
  explicit Game_bulletinfo_Response_Info(::google::protobuf::Arena* arena);
  Game_bulletinfo_Response_Info(::google::protobuf::Arena* arena, const Game_bulletinfo_Response_Info& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulletinfoFieldNumber = 2,
    kTankidFieldNumber = 1,
  };
  // repeated .Message.bulletinfo bulletinfo = 2;
  int bulletinfo_size() const;
  private:
  int _internal_bulletinfo_size() const;

  public:
  void clear_bulletinfo() ;
  ::Message::bulletinfo* mutable_bulletinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::bulletinfo >*
      mutable_bulletinfo();
  private:
  const ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>& _internal_bulletinfo() const;
  ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>* _internal_mutable_bulletinfo();
  public:
  const ::Message::bulletinfo& bulletinfo(int index) const;
  ::Message::bulletinfo* add_bulletinfo();
  const ::google::protobuf::RepeatedPtrField< ::Message::bulletinfo >&
      bulletinfo() const;
  // int32 tankid = 1;
  void clear_tankid() ;
  ::int32_t tankid() const;
  void set_tankid(::int32_t value);

  private:
  ::int32_t _internal_tankid() const;
  void _internal_set_tankid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message.Game_bulletinfo_Response.Info)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Message::bulletinfo > bulletinfo_;
    ::int32_t tankid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_bulletinfo_Request final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_bulletinfo_Request) */ {
 public:
  inline Game_bulletinfo_Request() : Game_bulletinfo_Request(nullptr) {}
  ~Game_bulletinfo_Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_bulletinfo_Request(::google::protobuf::internal::ConstantInitialized);

  inline Game_bulletinfo_Request(const Game_bulletinfo_Request& from)
      : Game_bulletinfo_Request(nullptr, from) {}
  Game_bulletinfo_Request(Game_bulletinfo_Request&& from) noexcept
    : Game_bulletinfo_Request() {
    *this = ::std::move(from);
  }

  inline Game_bulletinfo_Request& operator=(const Game_bulletinfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_bulletinfo_Request& operator=(Game_bulletinfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_bulletinfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_bulletinfo_Request* internal_default_instance() {
    return reinterpret_cast<const Game_bulletinfo_Request*>(
               &_Game_bulletinfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Game_bulletinfo_Request& a, Game_bulletinfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_bulletinfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_bulletinfo_Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_bulletinfo_Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_bulletinfo_Request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_bulletinfo_Request& from);
  void MergeFrom(const Game_bulletinfo_Request& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_bulletinfo_Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_bulletinfo_Request";
  }
  protected:
  explicit Game_bulletinfo_Request(::google::protobuf::Arena* arena);
  Game_bulletinfo_Request(::google::protobuf::Arena* arena, const Game_bulletinfo_Request& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulletinfoFieldNumber = 2,
  };
  // repeated .Message.bulletinfo bulletinfo = 2;
  int bulletinfo_size() const;
  private:
  int _internal_bulletinfo_size() const;

  public:
  void clear_bulletinfo() ;
  ::Message::bulletinfo* mutable_bulletinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::bulletinfo >*
      mutable_bulletinfo();
  private:
  const ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>& _internal_bulletinfo() const;
  ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>* _internal_mutable_bulletinfo();
  public:
  const ::Message::bulletinfo& bulletinfo(int index) const;
  ::Message::bulletinfo* add_bulletinfo();
  const ::google::protobuf::RepeatedPtrField< ::Message::bulletinfo >&
      bulletinfo() const;
  // @@protoc_insertion_point(class_scope:Message.Game_bulletinfo_Request)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Message::bulletinfo > bulletinfo_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_tankinfo_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_tankinfo_Response) */ {
 public:
  inline Game_tankinfo_Response() : Game_tankinfo_Response(nullptr) {}
  ~Game_tankinfo_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_tankinfo_Response(::google::protobuf::internal::ConstantInitialized);

  inline Game_tankinfo_Response(const Game_tankinfo_Response& from)
      : Game_tankinfo_Response(nullptr, from) {}
  Game_tankinfo_Response(Game_tankinfo_Response&& from) noexcept
    : Game_tankinfo_Response() {
    *this = ::std::move(from);
  }

  inline Game_tankinfo_Response& operator=(const Game_tankinfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_tankinfo_Response& operator=(Game_tankinfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_tankinfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_tankinfo_Response* internal_default_instance() {
    return reinterpret_cast<const Game_tankinfo_Response*>(
               &_Game_tankinfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Game_tankinfo_Response& a, Game_tankinfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_tankinfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_tankinfo_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_tankinfo_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_tankinfo_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_tankinfo_Response& from);
  void MergeFrom(const Game_tankinfo_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_tankinfo_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_tankinfo_Response";
  }
  protected:
  explicit Game_tankinfo_Response(::google::protobuf::Arena* arena);
  Game_tankinfo_Response(::google::protobuf::Arena* arena, const Game_tankinfo_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  using tankinfo = Game_tankinfo_Response_tankinfo;

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .Message.Game_tankinfo_Response.tankinfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::Message::Game_tankinfo_Response_tankinfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::Game_tankinfo_Response_tankinfo >*
      mutable_info();
  private:
  const ::google::protobuf::RepeatedPtrField<::Message::Game_tankinfo_Response_tankinfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::Message::Game_tankinfo_Response_tankinfo>* _internal_mutable_info();
  public:
  const ::Message::Game_tankinfo_Response_tankinfo& info(int index) const;
  ::Message::Game_tankinfo_Response_tankinfo* add_info();
  const ::google::protobuf::RepeatedPtrField< ::Message::Game_tankinfo_Response_tankinfo >&
      info() const;
  // @@protoc_insertion_point(class_scope:Message.Game_tankinfo_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Message::Game_tankinfo_Response_tankinfo > info_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};// -------------------------------------------------------------------

class Game_bulletinfo_Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:Message.Game_bulletinfo_Response) */ {
 public:
  inline Game_bulletinfo_Response() : Game_bulletinfo_Response(nullptr) {}
  ~Game_bulletinfo_Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Game_bulletinfo_Response(::google::protobuf::internal::ConstantInitialized);

  inline Game_bulletinfo_Response(const Game_bulletinfo_Response& from)
      : Game_bulletinfo_Response(nullptr, from) {}
  Game_bulletinfo_Response(Game_bulletinfo_Response&& from) noexcept
    : Game_bulletinfo_Response() {
    *this = ::std::move(from);
  }

  inline Game_bulletinfo_Response& operator=(const Game_bulletinfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_bulletinfo_Response& operator=(Game_bulletinfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Game_bulletinfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_bulletinfo_Response* internal_default_instance() {
    return reinterpret_cast<const Game_bulletinfo_Response*>(
               &_Game_bulletinfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Game_bulletinfo_Response& a, Game_bulletinfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_bulletinfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_bulletinfo_Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_bulletinfo_Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_bulletinfo_Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Game_bulletinfo_Response& from);
  void MergeFrom(const Game_bulletinfo_Response& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Game_bulletinfo_Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message.Game_bulletinfo_Response";
  }
  protected:
  explicit Game_bulletinfo_Response(::google::protobuf::Arena* arena);
  Game_bulletinfo_Response(::google::protobuf::Arena* arena, const Game_bulletinfo_Response& from);
  const ::google::protobuf::MessageLite::ClassData* GetClassData() const final;
  public:

  // nested types ----------------------------------------------------

  using Info = Game_bulletinfo_Response_Info;

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .Message.Game_bulletinfo_Response.Info info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::Message::Game_bulletinfo_Response_Info* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField< ::Message::Game_bulletinfo_Response_Info >*
      mutable_info();
  private:
  const ::google::protobuf::RepeatedPtrField<::Message::Game_bulletinfo_Response_Info>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::Message::Game_bulletinfo_Response_Info>* _internal_mutable_info();
  public:
  const ::Message::Game_bulletinfo_Response_Info& info(int index) const;
  ::Message::Game_bulletinfo_Response_Info* add_info();
  const ::google::protobuf::RepeatedPtrField< ::Message::Game_bulletinfo_Response_Info >&
      info() const;
  // @@protoc_insertion_point(class_scope:Message.Game_bulletinfo_Response)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Message::Game_bulletinfo_Response_Info > info_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Hall_info_Response_User

// string name = 1;
inline void Hall_info_Response_User::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Hall_info_Response_User::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.User.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Hall_info_Response_User::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Hall_info_Response.User.name)
}
inline std::string* Hall_info_Response_User::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Hall_info_Response.User.name)
  return _s;
}
inline const std::string& Hall_info_Response_User::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Hall_info_Response_User::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Hall_info_Response_User::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Hall_info_Response_User::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Hall_info_Response.User.name)
  return _impl_.name_.Release();
}
inline void Hall_info_Response_User::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_info_Response.User.name)
}

// -------------------------------------------------------------------

// Hall_info_Response_Roominfo

// int32 room_id = 1;
inline void Hall_info_Response_Roominfo::clear_room_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.room_id_ = 0;
}
inline ::int32_t Hall_info_Response_Roominfo::room_id() const {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.Roominfo.room_id)
  return _internal_room_id();
}
inline void Hall_info_Response_Roominfo::set_room_id(::int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Message.Hall_info_Response.Roominfo.room_id)
}
inline ::int32_t Hall_info_Response_Roominfo::_internal_room_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.room_id_;
}
inline void Hall_info_Response_Roominfo::_internal_set_room_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.room_id_ = value;
}

// string host_name = 2;
inline void Hall_info_Response_Roominfo::clear_host_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_name_.ClearToEmpty();
}
inline const std::string& Hall_info_Response_Roominfo::host_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.Roominfo.host_name)
  return _internal_host_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Hall_info_Response_Roominfo::set_host_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Hall_info_Response.Roominfo.host_name)
}
inline std::string* Hall_info_Response_Roominfo::mutable_host_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_host_name();
  // @@protoc_insertion_point(field_mutable:Message.Hall_info_Response.Roominfo.host_name)
  return _s;
}
inline const std::string& Hall_info_Response_Roominfo::_internal_host_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.host_name_.Get();
}
inline void Hall_info_Response_Roominfo::_internal_set_host_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.host_name_.Set(value, GetArena());
}
inline std::string* Hall_info_Response_Roominfo::_internal_mutable_host_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.host_name_.Mutable( GetArena());
}
inline std::string* Hall_info_Response_Roominfo::release_host_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Hall_info_Response.Roominfo.host_name)
  return _impl_.host_name_.Release();
}
inline void Hall_info_Response_Roominfo::set_allocated_host_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.host_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_name_.IsDefault()) {
          _impl_.host_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_info_Response.Roominfo.host_name)
}

// -------------------------------------------------------------------

// Hall_info_Response

// repeated .Message.Hall_info_Response.User userinfo = 1;
inline int Hall_info_Response::_internal_userinfo_size() const {
  return _internal_userinfo().size();
}
inline int Hall_info_Response::userinfo_size() const {
  return _internal_userinfo_size();
}
inline void Hall_info_Response::clear_userinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userinfo_.Clear();
}
inline ::Message::Hall_info_Response_User* Hall_info_Response::mutable_userinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Message.Hall_info_Response.userinfo)
  return _internal_mutable_userinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_User>* Hall_info_Response::mutable_userinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Message.Hall_info_Response.userinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_userinfo();
}
inline const ::Message::Hall_info_Response_User& Hall_info_Response::userinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.userinfo)
  return _internal_userinfo().Get(index);
}
inline ::Message::Hall_info_Response_User* Hall_info_Response::add_userinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Message::Hall_info_Response_User* _add = _internal_mutable_userinfo()->Add();
  // @@protoc_insertion_point(field_add:Message.Hall_info_Response.userinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_User>& Hall_info_Response::userinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Message.Hall_info_Response.userinfo)
  return _internal_userinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_User>&
Hall_info_Response::_internal_userinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_User>*
Hall_info_Response::_internal_mutable_userinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.userinfo_;
}

// repeated .Message.Hall_info_Response.Roominfo roominfo = 2;
inline int Hall_info_Response::_internal_roominfo_size() const {
  return _internal_roominfo().size();
}
inline int Hall_info_Response::roominfo_size() const {
  return _internal_roominfo_size();
}
inline void Hall_info_Response::clear_roominfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roominfo_.Clear();
}
inline ::Message::Hall_info_Response_Roominfo* Hall_info_Response::mutable_roominfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Message.Hall_info_Response.roominfo)
  return _internal_mutable_roominfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_Roominfo>* Hall_info_Response::mutable_roominfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Message.Hall_info_Response.roominfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_roominfo();
}
inline const ::Message::Hall_info_Response_Roominfo& Hall_info_Response::roominfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.roominfo)
  return _internal_roominfo().Get(index);
}
inline ::Message::Hall_info_Response_Roominfo* Hall_info_Response::add_roominfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Message::Hall_info_Response_Roominfo* _add = _internal_mutable_roominfo()->Add();
  // @@protoc_insertion_point(field_add:Message.Hall_info_Response.roominfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_Roominfo>& Hall_info_Response::roominfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Message.Hall_info_Response.roominfo)
  return _internal_roominfo();
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_Roominfo>&
Hall_info_Response::_internal_roominfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roominfo_;
}
inline ::google::protobuf::RepeatedPtrField<::Message::Hall_info_Response_Roominfo>*
Hall_info_Response::_internal_mutable_roominfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.roominfo_;
}

// -------------------------------------------------------------------

// Hall_Message_Request

// string content = 1;
inline void Hall_Message_Request::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Hall_Message_Request::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Hall_Message_Request.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Hall_Message_Request::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Hall_Message_Request.content)
}
inline std::string* Hall_Message_Request::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Message.Hall_Message_Request.content)
  return _s;
}
inline const std::string& Hall_Message_Request::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void Hall_Message_Request::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* Hall_Message_Request::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* Hall_Message_Request::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Hall_Message_Request.content)
  return _impl_.content_.Release();
}
inline void Hall_Message_Request::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_Message_Request.content)
}

// -------------------------------------------------------------------

// Hall_Message_Response

// string name = 1;
inline void Hall_Message_Response::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Hall_Message_Response::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Hall_Message_Response.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Hall_Message_Response::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Hall_Message_Response.name)
}
inline std::string* Hall_Message_Response::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Hall_Message_Response.name)
  return _s;
}
inline const std::string& Hall_Message_Response::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Hall_Message_Response::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Hall_Message_Response::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Hall_Message_Response::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Hall_Message_Response.name)
  return _impl_.name_.Release();
}
inline void Hall_Message_Response::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_Message_Response.name)
}

// string content = 2;
inline void Hall_Message_Response::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Hall_Message_Response::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Hall_Message_Response.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Hall_Message_Response::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Hall_Message_Response.content)
}
inline std::string* Hall_Message_Response::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Message.Hall_Message_Response.content)
  return _s;
}
inline const std::string& Hall_Message_Response::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void Hall_Message_Response::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* Hall_Message_Response::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* Hall_Message_Response::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Hall_Message_Response.content)
  return _impl_.content_.Release();
}
inline void Hall_Message_Response::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_Message_Response.content)
}

// -------------------------------------------------------------------

// Hall_EnterRoom_Request

// int32 room_id = 1;
inline void Hall_EnterRoom_Request::clear_room_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.room_id_ = 0;
}
inline ::int32_t Hall_EnterRoom_Request::room_id() const {
  // @@protoc_insertion_point(field_get:Message.Hall_EnterRoom_Request.room_id)
  return _internal_room_id();
}
inline void Hall_EnterRoom_Request::set_room_id(::int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Message.Hall_EnterRoom_Request.room_id)
}
inline ::int32_t Hall_EnterRoom_Request::_internal_room_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.room_id_;
}
inline void Hall_EnterRoom_Request::_internal_set_room_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.room_id_ = value;
}

// -------------------------------------------------------------------

// Hall_EnterRoom_Response

// int32 room_id = 1;
inline void Hall_EnterRoom_Response::clear_room_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.room_id_ = 0;
}
inline ::int32_t Hall_EnterRoom_Response::room_id() const {
  // @@protoc_insertion_point(field_get:Message.Hall_EnterRoom_Response.room_id)
  return _internal_room_id();
}
inline void Hall_EnterRoom_Response::set_room_id(::int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Message.Hall_EnterRoom_Response.room_id)
}
inline ::int32_t Hall_EnterRoom_Response::_internal_room_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.room_id_;
}
inline void Hall_EnterRoom_Response::_internal_set_room_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.room_id_ = value;
}

// int32 result = 2;
inline void Hall_EnterRoom_Response::clear_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_ = 0;
}
inline ::int32_t Hall_EnterRoom_Response::result() const {
  // @@protoc_insertion_point(field_get:Message.Hall_EnterRoom_Response.result)
  return _internal_result();
}
inline void Hall_EnterRoom_Response::set_result(::int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Message.Hall_EnterRoom_Response.result)
}
inline ::int32_t Hall_EnterRoom_Response::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_;
}
inline void Hall_EnterRoom_Response::_internal_set_result(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// Ping_info

// int32 ping_id = 1;
inline void Ping_info::clear_ping_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ping_id_ = 0;
}
inline ::int32_t Ping_info::ping_id() const {
  // @@protoc_insertion_point(field_get:Message.Ping_info.ping_id)
  return _internal_ping_id();
}
inline void Ping_info::set_ping_id(::int32_t value) {
  _internal_set_ping_id(value);
  // @@protoc_insertion_point(field_set:Message.Ping_info.ping_id)
}
inline ::int32_t Ping_info::_internal_ping_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ping_id_;
}
inline void Ping_info::_internal_set_ping_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ping_id_ = value;
}

// -------------------------------------------------------------------

// Set_User_id

// string name = 1;
inline void Set_User_id::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Set_User_id::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Set_User_id.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Set_User_id::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Set_User_id.name)
}
inline std::string* Set_User_id::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Set_User_id.name)
  return _s;
}
inline const std::string& Set_User_id::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Set_User_id::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Set_User_id::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Set_User_id::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Set_User_id.name)
  return _impl_.name_.Release();
}
inline void Set_User_id::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Set_User_id.name)
}

// -------------------------------------------------------------------

// Room_info_Response_User

// string name = 1;
inline void Room_info_Response_User::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Room_info_Response_User::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Room_info_Response.User.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Room_info_Response_User::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Room_info_Response.User.name)
}
inline std::string* Room_info_Response_User::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Room_info_Response.User.name)
  return _s;
}
inline const std::string& Room_info_Response_User::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Room_info_Response_User::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Room_info_Response_User::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Room_info_Response_User::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Room_info_Response.User.name)
  return _impl_.name_.Release();
}
inline void Room_info_Response_User::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Room_info_Response.User.name)
}

// int32 status = 2;
inline void Room_info_Response_User::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
}
inline ::int32_t Room_info_Response_User::status() const {
  // @@protoc_insertion_point(field_get:Message.Room_info_Response.User.status)
  return _internal_status();
}
inline void Room_info_Response_User::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Message.Room_info_Response.User.status)
}
inline ::int32_t Room_info_Response_User::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void Room_info_Response_User::_internal_set_status(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// Room_info_Response

// repeated .Message.Room_info_Response.User userinfo = 1;
inline int Room_info_Response::_internal_userinfo_size() const {
  return _internal_userinfo().size();
}
inline int Room_info_Response::userinfo_size() const {
  return _internal_userinfo_size();
}
inline void Room_info_Response::clear_userinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userinfo_.Clear();
}
inline ::Message::Room_info_Response_User* Room_info_Response::mutable_userinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Message.Room_info_Response.userinfo)
  return _internal_mutable_userinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Message::Room_info_Response_User>* Room_info_Response::mutable_userinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Message.Room_info_Response.userinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_userinfo();
}
inline const ::Message::Room_info_Response_User& Room_info_Response::userinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Room_info_Response.userinfo)
  return _internal_userinfo().Get(index);
}
inline ::Message::Room_info_Response_User* Room_info_Response::add_userinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Message::Room_info_Response_User* _add = _internal_mutable_userinfo()->Add();
  // @@protoc_insertion_point(field_add:Message.Room_info_Response.userinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Room_info_Response_User>& Room_info_Response::userinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Message.Room_info_Response.userinfo)
  return _internal_userinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Room_info_Response_User>&
Room_info_Response::_internal_userinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::Message::Room_info_Response_User>*
Room_info_Response::_internal_mutable_userinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.userinfo_;
}

// -------------------------------------------------------------------

// Room_Message_Request

// string content = 1;
inline void Room_Message_Request::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Room_Message_Request::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Room_Message_Request.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Room_Message_Request::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Room_Message_Request.content)
}
inline std::string* Room_Message_Request::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Message.Room_Message_Request.content)
  return _s;
}
inline const std::string& Room_Message_Request::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void Room_Message_Request::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* Room_Message_Request::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* Room_Message_Request::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Room_Message_Request.content)
  return _impl_.content_.Release();
}
inline void Room_Message_Request::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Room_Message_Request.content)
}

// -------------------------------------------------------------------

// Room_Message_Response

// string name = 1;
inline void Room_Message_Response::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Room_Message_Response::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Room_Message_Response.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Room_Message_Response::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Room_Message_Response.name)
}
inline std::string* Room_Message_Response::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Room_Message_Response.name)
  return _s;
}
inline const std::string& Room_Message_Response::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Room_Message_Response::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Room_Message_Response::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Room_Message_Response::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Room_Message_Response.name)
  return _impl_.name_.Release();
}
inline void Room_Message_Response::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Room_Message_Response.name)
}

// string content = 2;
inline void Room_Message_Response::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Room_Message_Response::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Room_Message_Response.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Room_Message_Response::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.Room_Message_Response.content)
}
inline std::string* Room_Message_Response::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Message.Room_Message_Response.content)
  return _s;
}
inline const std::string& Room_Message_Response::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void Room_Message_Response::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* Room_Message_Response::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* Room_Message_Response::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Room_Message_Response.content)
  return _impl_.content_.Release();
}
inline void Room_Message_Response::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Room_Message_Response.content)
}

// -------------------------------------------------------------------

// Room_Set_tankid

// int32 id = 1;
inline void Room_Set_tankid::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Room_Set_tankid::id() const {
  // @@protoc_insertion_point(field_get:Message.Room_Set_tankid.id)
  return _internal_id();
}
inline void Room_Set_tankid::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Message.Room_Set_tankid.id)
}
inline ::int32_t Room_Set_tankid::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Room_Set_tankid::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// Room_Set_tankid_Response

// int32 id = 1;
inline void Room_Set_tankid_Response::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Room_Set_tankid_Response::id() const {
  // @@protoc_insertion_point(field_get:Message.Room_Set_tankid_Response.id)
  return _internal_id();
}
inline void Room_Set_tankid_Response::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Message.Room_Set_tankid_Response.id)
}
inline ::int32_t Room_Set_tankid_Response::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Room_Set_tankid_Response::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// Room_Start_Response

// int32 result = 1;
inline void Room_Start_Response::clear_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_ = 0;
}
inline ::int32_t Room_Start_Response::result() const {
  // @@protoc_insertion_point(field_get:Message.Room_Start_Response.result)
  return _internal_result();
}
inline void Room_Start_Response::set_result(::int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Message.Room_Start_Response.result)
}
inline ::int32_t Room_Start_Response::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_;
}
inline void Room_Start_Response::_internal_set_result(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// Game_tankinfo_Request

// double locationX = 1;
inline void Game_tankinfo_Request::clear_locationx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locationx_ = 0;
}
inline double Game_tankinfo_Request::locationx() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Request.locationX)
  return _internal_locationx();
}
inline void Game_tankinfo_Request::set_locationx(double value) {
  _internal_set_locationx(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Request.locationX)
}
inline double Game_tankinfo_Request::_internal_locationx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationx_;
}
inline void Game_tankinfo_Request::_internal_set_locationx(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.locationx_ = value;
}

// double locationY = 2;
inline void Game_tankinfo_Request::clear_locationy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locationy_ = 0;
}
inline double Game_tankinfo_Request::locationy() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Request.locationY)
  return _internal_locationy();
}
inline void Game_tankinfo_Request::set_locationy(double value) {
  _internal_set_locationy(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Request.locationY)
}
inline double Game_tankinfo_Request::_internal_locationy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationy_;
}
inline void Game_tankinfo_Request::_internal_set_locationy(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.locationy_ = value;
}

// double rotate = 3;
inline void Game_tankinfo_Request::clear_rotate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotate_ = 0;
}
inline double Game_tankinfo_Request::rotate() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Request.rotate)
  return _internal_rotate();
}
inline void Game_tankinfo_Request::set_rotate(double value) {
  _internal_set_rotate(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Request.rotate)
}
inline double Game_tankinfo_Request::_internal_rotate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotate_;
}
inline void Game_tankinfo_Request::_internal_set_rotate(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rotate_ = value;
}

// int32 tank_style = 4;
inline void Game_tankinfo_Request::clear_tank_style() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tank_style_ = 0;
}
inline ::int32_t Game_tankinfo_Request::tank_style() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Request.tank_style)
  return _internal_tank_style();
}
inline void Game_tankinfo_Request::set_tank_style(::int32_t value) {
  _internal_set_tank_style(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Request.tank_style)
}
inline ::int32_t Game_tankinfo_Request::_internal_tank_style() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tank_style_;
}
inline void Game_tankinfo_Request::_internal_set_tank_style(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tank_style_ = value;
}

// -------------------------------------------------------------------

// Game_tankinfo_Response_tankinfo

// int32 id = 1;
inline void Game_tankinfo_Response_tankinfo::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Game_tankinfo_Response_tankinfo::id() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Response.tankinfo.id)
  return _internal_id();
}
inline void Game_tankinfo_Response_tankinfo::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Response.tankinfo.id)
}
inline ::int32_t Game_tankinfo_Response_tankinfo::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Game_tankinfo_Response_tankinfo::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .Message.Game_tankinfo_Request tankinfo = 2;
inline bool Game_tankinfo_Response_tankinfo::has_tankinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tankinfo_ != nullptr);
  return value;
}
inline void Game_tankinfo_Response_tankinfo::clear_tankinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tankinfo_ != nullptr) _impl_.tankinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Message::Game_tankinfo_Request& Game_tankinfo_Response_tankinfo::_internal_tankinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Message::Game_tankinfo_Request* p = _impl_.tankinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Message::Game_tankinfo_Request&>(::Message::_Game_tankinfo_Request_default_instance_);
}
inline const ::Message::Game_tankinfo_Request& Game_tankinfo_Response_tankinfo::tankinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Response.tankinfo.tankinfo)
  return _internal_tankinfo();
}
inline void Game_tankinfo_Response_tankinfo::unsafe_arena_set_allocated_tankinfo(::Message::Game_tankinfo_Request* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tankinfo_);
  }
  _impl_.tankinfo_ = reinterpret_cast<::Message::Game_tankinfo_Request*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.Game_tankinfo_Response.tankinfo.tankinfo)
}
inline ::Message::Game_tankinfo_Request* Game_tankinfo_Response_tankinfo::release_tankinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Message::Game_tankinfo_Request* released = _impl_.tankinfo_;
  _impl_.tankinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Message::Game_tankinfo_Request* Game_tankinfo_Response_tankinfo::unsafe_arena_release_tankinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Game_tankinfo_Response.tankinfo.tankinfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Message::Game_tankinfo_Request* temp = _impl_.tankinfo_;
  _impl_.tankinfo_ = nullptr;
  return temp;
}
inline ::Message::Game_tankinfo_Request* Game_tankinfo_Response_tankinfo::_internal_mutable_tankinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tankinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Message::Game_tankinfo_Request>(GetArena());
    _impl_.tankinfo_ = reinterpret_cast<::Message::Game_tankinfo_Request*>(p);
  }
  return _impl_.tankinfo_;
}
inline ::Message::Game_tankinfo_Request* Game_tankinfo_Response_tankinfo::mutable_tankinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Message::Game_tankinfo_Request* _msg = _internal_mutable_tankinfo();
  // @@protoc_insertion_point(field_mutable:Message.Game_tankinfo_Response.tankinfo.tankinfo)
  return _msg;
}
inline void Game_tankinfo_Response_tankinfo::set_allocated_tankinfo(::Message::Game_tankinfo_Request* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.tankinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tankinfo_ = reinterpret_cast<::Message::Game_tankinfo_Request*>(value);
  // @@protoc_insertion_point(field_set_allocated:Message.Game_tankinfo_Response.tankinfo.tankinfo)
}

// int32 health = 3;
inline void Game_tankinfo_Response_tankinfo::clear_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.health_ = 0;
}
inline ::int32_t Game_tankinfo_Response_tankinfo::health() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Response.tankinfo.health)
  return _internal_health();
}
inline void Game_tankinfo_Response_tankinfo::set_health(::int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Response.tankinfo.health)
}
inline ::int32_t Game_tankinfo_Response_tankinfo::_internal_health() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.health_;
}
inline void Game_tankinfo_Response_tankinfo::_internal_set_health(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.health_ = value;
}

// -------------------------------------------------------------------

// Game_tankinfo_Response

// repeated .Message.Game_tankinfo_Response.tankinfo info = 1;
inline int Game_tankinfo_Response::_internal_info_size() const {
  return _internal_info().size();
}
inline int Game_tankinfo_Response::info_size() const {
  return _internal_info_size();
}
inline void Game_tankinfo_Response::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::Message::Game_tankinfo_Response_tankinfo* Game_tankinfo_Response::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Message.Game_tankinfo_Response.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Message::Game_tankinfo_Response_tankinfo>* Game_tankinfo_Response::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Message.Game_tankinfo_Response.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::Message::Game_tankinfo_Response_tankinfo& Game_tankinfo_Response::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Response.info)
  return _internal_info().Get(index);
}
inline ::Message::Game_tankinfo_Response_tankinfo* Game_tankinfo_Response::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Message::Game_tankinfo_Response_tankinfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:Message.Game_tankinfo_Response.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Game_tankinfo_Response_tankinfo>& Game_tankinfo_Response::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Message.Game_tankinfo_Response.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Game_tankinfo_Response_tankinfo>&
Game_tankinfo_Response::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::Message::Game_tankinfo_Response_tankinfo>*
Game_tankinfo_Response::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// bulletinfo

// double locationX = 1;
inline void bulletinfo::clear_locationx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locationx_ = 0;
}
inline double bulletinfo::locationx() const {
  // @@protoc_insertion_point(field_get:Message.bulletinfo.locationX)
  return _internal_locationx();
}
inline void bulletinfo::set_locationx(double value) {
  _internal_set_locationx(value);
  // @@protoc_insertion_point(field_set:Message.bulletinfo.locationX)
}
inline double bulletinfo::_internal_locationx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationx_;
}
inline void bulletinfo::_internal_set_locationx(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.locationx_ = value;
}

// double locationY = 2;
inline void bulletinfo::clear_locationy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locationy_ = 0;
}
inline double bulletinfo::locationy() const {
  // @@protoc_insertion_point(field_get:Message.bulletinfo.locationY)
  return _internal_locationy();
}
inline void bulletinfo::set_locationy(double value) {
  _internal_set_locationy(value);
  // @@protoc_insertion_point(field_set:Message.bulletinfo.locationY)
}
inline double bulletinfo::_internal_locationy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locationy_;
}
inline void bulletinfo::_internal_set_locationy(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.locationy_ = value;
}

// double rotate = 3;
inline void bulletinfo::clear_rotate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotate_ = 0;
}
inline double bulletinfo::rotate() const {
  // @@protoc_insertion_point(field_get:Message.bulletinfo.rotate)
  return _internal_rotate();
}
inline void bulletinfo::set_rotate(double value) {
  _internal_set_rotate(value);
  // @@protoc_insertion_point(field_set:Message.bulletinfo.rotate)
}
inline double bulletinfo::_internal_rotate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotate_;
}
inline void bulletinfo::_internal_set_rotate(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rotate_ = value;
}

// int32 bullet_style = 4;
inline void bulletinfo::clear_bullet_style() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bullet_style_ = 0;
}
inline ::int32_t bulletinfo::bullet_style() const {
  // @@protoc_insertion_point(field_get:Message.bulletinfo.bullet_style)
  return _internal_bullet_style();
}
inline void bulletinfo::set_bullet_style(::int32_t value) {
  _internal_set_bullet_style(value);
  // @@protoc_insertion_point(field_set:Message.bulletinfo.bullet_style)
}
inline ::int32_t bulletinfo::_internal_bullet_style() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bullet_style_;
}
inline void bulletinfo::_internal_set_bullet_style(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bullet_style_ = value;
}

// -------------------------------------------------------------------

// Game_bulletinfo_Request

// repeated .Message.bulletinfo bulletinfo = 2;
inline int Game_bulletinfo_Request::_internal_bulletinfo_size() const {
  return _internal_bulletinfo().size();
}
inline int Game_bulletinfo_Request::bulletinfo_size() const {
  return _internal_bulletinfo_size();
}
inline void Game_bulletinfo_Request::clear_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bulletinfo_.Clear();
}
inline ::Message::bulletinfo* Game_bulletinfo_Request::mutable_bulletinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Message.Game_bulletinfo_Request.bulletinfo)
  return _internal_mutable_bulletinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>* Game_bulletinfo_Request::mutable_bulletinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Message.Game_bulletinfo_Request.bulletinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_bulletinfo();
}
inline const ::Message::bulletinfo& Game_bulletinfo_Request::bulletinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Game_bulletinfo_Request.bulletinfo)
  return _internal_bulletinfo().Get(index);
}
inline ::Message::bulletinfo* Game_bulletinfo_Request::add_bulletinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Message::bulletinfo* _add = _internal_mutable_bulletinfo()->Add();
  // @@protoc_insertion_point(field_add:Message.Game_bulletinfo_Request.bulletinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>& Game_bulletinfo_Request::bulletinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Message.Game_bulletinfo_Request.bulletinfo)
  return _internal_bulletinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>&
Game_bulletinfo_Request::_internal_bulletinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bulletinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>*
Game_bulletinfo_Request::_internal_mutable_bulletinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.bulletinfo_;
}

// -------------------------------------------------------------------

// Game_bulletinfo_Response_Info

// int32 tankid = 1;
inline void Game_bulletinfo_Response_Info::clear_tankid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tankid_ = 0;
}
inline ::int32_t Game_bulletinfo_Response_Info::tankid() const {
  // @@protoc_insertion_point(field_get:Message.Game_bulletinfo_Response.Info.tankid)
  return _internal_tankid();
}
inline void Game_bulletinfo_Response_Info::set_tankid(::int32_t value) {
  _internal_set_tankid(value);
  // @@protoc_insertion_point(field_set:Message.Game_bulletinfo_Response.Info.tankid)
}
inline ::int32_t Game_bulletinfo_Response_Info::_internal_tankid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tankid_;
}
inline void Game_bulletinfo_Response_Info::_internal_set_tankid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tankid_ = value;
}

// repeated .Message.bulletinfo bulletinfo = 2;
inline int Game_bulletinfo_Response_Info::_internal_bulletinfo_size() const {
  return _internal_bulletinfo().size();
}
inline int Game_bulletinfo_Response_Info::bulletinfo_size() const {
  return _internal_bulletinfo_size();
}
inline void Game_bulletinfo_Response_Info::clear_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bulletinfo_.Clear();
}
inline ::Message::bulletinfo* Game_bulletinfo_Response_Info::mutable_bulletinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Message.Game_bulletinfo_Response.Info.bulletinfo)
  return _internal_mutable_bulletinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>* Game_bulletinfo_Response_Info::mutable_bulletinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Message.Game_bulletinfo_Response.Info.bulletinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_bulletinfo();
}
inline const ::Message::bulletinfo& Game_bulletinfo_Response_Info::bulletinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Game_bulletinfo_Response.Info.bulletinfo)
  return _internal_bulletinfo().Get(index);
}
inline ::Message::bulletinfo* Game_bulletinfo_Response_Info::add_bulletinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Message::bulletinfo* _add = _internal_mutable_bulletinfo()->Add();
  // @@protoc_insertion_point(field_add:Message.Game_bulletinfo_Response.Info.bulletinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>& Game_bulletinfo_Response_Info::bulletinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Message.Game_bulletinfo_Response.Info.bulletinfo)
  return _internal_bulletinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>&
Game_bulletinfo_Response_Info::_internal_bulletinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bulletinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::Message::bulletinfo>*
Game_bulletinfo_Response_Info::_internal_mutable_bulletinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.bulletinfo_;
}

// -------------------------------------------------------------------

// Game_bulletinfo_Response

// repeated .Message.Game_bulletinfo_Response.Info info = 1;
inline int Game_bulletinfo_Response::_internal_info_size() const {
  return _internal_info().size();
}
inline int Game_bulletinfo_Response::info_size() const {
  return _internal_info_size();
}
inline void Game_bulletinfo_Response::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::Message::Game_bulletinfo_Response_Info* Game_bulletinfo_Response::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Message.Game_bulletinfo_Response.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Message::Game_bulletinfo_Response_Info>* Game_bulletinfo_Response::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Message.Game_bulletinfo_Response.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::Message::Game_bulletinfo_Response_Info& Game_bulletinfo_Response::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Game_bulletinfo_Response.info)
  return _internal_info().Get(index);
}
inline ::Message::Game_bulletinfo_Response_Info* Game_bulletinfo_Response::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Message::Game_bulletinfo_Response_Info* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:Message.Game_bulletinfo_Response.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Game_bulletinfo_Response_Info>& Game_bulletinfo_Response::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Message.Game_bulletinfo_Response.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::Message::Game_bulletinfo_Response_Info>&
Game_bulletinfo_Response::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::Message::Game_bulletinfo_Response_Info>*
Game_bulletinfo_Response::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// Game_hit_brick_Request

// int32 hited_brick_id = 1;
inline void Game_hit_brick_Request::clear_hited_brick_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hited_brick_id_ = 0;
}
inline ::int32_t Game_hit_brick_Request::hited_brick_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_hit_brick_Request.hited_brick_id)
  return _internal_hited_brick_id();
}
inline void Game_hit_brick_Request::set_hited_brick_id(::int32_t value) {
  _internal_set_hited_brick_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_hit_brick_Request.hited_brick_id)
}
inline ::int32_t Game_hit_brick_Request::_internal_hited_brick_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hited_brick_id_;
}
inline void Game_hit_brick_Request::_internal_set_hited_brick_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hited_brick_id_ = value;
}

// .Message.bulletinfo bulletinfo = 2;
inline bool Game_hit_brick_Request::has_bulletinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bulletinfo_ != nullptr);
  return value;
}
inline void Game_hit_brick_Request::clear_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bulletinfo_ != nullptr) _impl_.bulletinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Message::bulletinfo& Game_hit_brick_Request::_internal_bulletinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Message::bulletinfo* p = _impl_.bulletinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Message::bulletinfo&>(::Message::_bulletinfo_default_instance_);
}
inline const ::Message::bulletinfo& Game_hit_brick_Request::bulletinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Game_hit_brick_Request.bulletinfo)
  return _internal_bulletinfo();
}
inline void Game_hit_brick_Request::unsafe_arena_set_allocated_bulletinfo(::Message::bulletinfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bulletinfo_);
  }
  _impl_.bulletinfo_ = reinterpret_cast<::Message::bulletinfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.Game_hit_brick_Request.bulletinfo)
}
inline ::Message::bulletinfo* Game_hit_brick_Request::release_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Message::bulletinfo* released = _impl_.bulletinfo_;
  _impl_.bulletinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Message::bulletinfo* Game_hit_brick_Request::unsafe_arena_release_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Game_hit_brick_Request.bulletinfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Message::bulletinfo* temp = _impl_.bulletinfo_;
  _impl_.bulletinfo_ = nullptr;
  return temp;
}
inline ::Message::bulletinfo* Game_hit_brick_Request::_internal_mutable_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.bulletinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Message::bulletinfo>(GetArena());
    _impl_.bulletinfo_ = reinterpret_cast<::Message::bulletinfo*>(p);
  }
  return _impl_.bulletinfo_;
}
inline ::Message::bulletinfo* Game_hit_brick_Request::mutable_bulletinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Message::bulletinfo* _msg = _internal_mutable_bulletinfo();
  // @@protoc_insertion_point(field_mutable:Message.Game_hit_brick_Request.bulletinfo)
  return _msg;
}
inline void Game_hit_brick_Request::set_allocated_bulletinfo(::Message::bulletinfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.bulletinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bulletinfo_ = reinterpret_cast<::Message::bulletinfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:Message.Game_hit_brick_Request.bulletinfo)
}

// -------------------------------------------------------------------

// Game_brick_hited_Response

// int32 hited_brick_id = 1;
inline void Game_brick_hited_Response::clear_hited_brick_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hited_brick_id_ = 0;
}
inline ::int32_t Game_brick_hited_Response::hited_brick_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_brick_hited_Response.hited_brick_id)
  return _internal_hited_brick_id();
}
inline void Game_brick_hited_Response::set_hited_brick_id(::int32_t value) {
  _internal_set_hited_brick_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_brick_hited_Response.hited_brick_id)
}
inline ::int32_t Game_brick_hited_Response::_internal_hited_brick_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hited_brick_id_;
}
inline void Game_brick_hited_Response::_internal_set_hited_brick_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hited_brick_id_ = value;
}

// int32 health = 2;
inline void Game_brick_hited_Response::clear_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.health_ = 0;
}
inline ::int32_t Game_brick_hited_Response::health() const {
  // @@protoc_insertion_point(field_get:Message.Game_brick_hited_Response.health)
  return _internal_health();
}
inline void Game_brick_hited_Response::set_health(::int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:Message.Game_brick_hited_Response.health)
}
inline ::int32_t Game_brick_hited_Response::_internal_health() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.health_;
}
inline void Game_brick_hited_Response::_internal_set_health(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.health_ = value;
}

// -------------------------------------------------------------------

// Game_hit_tank_Request

// int32 hited_tank_id = 1;
inline void Game_hit_tank_Request::clear_hited_tank_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hited_tank_id_ = 0;
}
inline ::int32_t Game_hit_tank_Request::hited_tank_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_hit_tank_Request.hited_tank_id)
  return _internal_hited_tank_id();
}
inline void Game_hit_tank_Request::set_hited_tank_id(::int32_t value) {
  _internal_set_hited_tank_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_hit_tank_Request.hited_tank_id)
}
inline ::int32_t Game_hit_tank_Request::_internal_hited_tank_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hited_tank_id_;
}
inline void Game_hit_tank_Request::_internal_set_hited_tank_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hited_tank_id_ = value;
}

// .Message.bulletinfo bulletinfo = 2;
inline bool Game_hit_tank_Request::has_bulletinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bulletinfo_ != nullptr);
  return value;
}
inline void Game_hit_tank_Request::clear_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bulletinfo_ != nullptr) _impl_.bulletinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Message::bulletinfo& Game_hit_tank_Request::_internal_bulletinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Message::bulletinfo* p = _impl_.bulletinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Message::bulletinfo&>(::Message::_bulletinfo_default_instance_);
}
inline const ::Message::bulletinfo& Game_hit_tank_Request::bulletinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.Game_hit_tank_Request.bulletinfo)
  return _internal_bulletinfo();
}
inline void Game_hit_tank_Request::unsafe_arena_set_allocated_bulletinfo(::Message::bulletinfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bulletinfo_);
  }
  _impl_.bulletinfo_ = reinterpret_cast<::Message::bulletinfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.Game_hit_tank_Request.bulletinfo)
}
inline ::Message::bulletinfo* Game_hit_tank_Request::release_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Message::bulletinfo* released = _impl_.bulletinfo_;
  _impl_.bulletinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Message::bulletinfo* Game_hit_tank_Request::unsafe_arena_release_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.Game_hit_tank_Request.bulletinfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Message::bulletinfo* temp = _impl_.bulletinfo_;
  _impl_.bulletinfo_ = nullptr;
  return temp;
}
inline ::Message::bulletinfo* Game_hit_tank_Request::_internal_mutable_bulletinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.bulletinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Message::bulletinfo>(GetArena());
    _impl_.bulletinfo_ = reinterpret_cast<::Message::bulletinfo*>(p);
  }
  return _impl_.bulletinfo_;
}
inline ::Message::bulletinfo* Game_hit_tank_Request::mutable_bulletinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Message::bulletinfo* _msg = _internal_mutable_bulletinfo();
  // @@protoc_insertion_point(field_mutable:Message.Game_hit_tank_Request.bulletinfo)
  return _msg;
}
inline void Game_hit_tank_Request::set_allocated_bulletinfo(::Message::bulletinfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.bulletinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bulletinfo_ = reinterpret_cast<::Message::bulletinfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:Message.Game_hit_tank_Request.bulletinfo)
}

// -------------------------------------------------------------------

// Game_tank_hited_Response

// int32 hited_tank_id = 1;
inline void Game_tank_hited_Response::clear_hited_tank_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hited_tank_id_ = 0;
}
inline ::int32_t Game_tank_hited_Response::hited_tank_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_tank_hited_Response.hited_tank_id)
  return _internal_hited_tank_id();
}
inline void Game_tank_hited_Response::set_hited_tank_id(::int32_t value) {
  _internal_set_hited_tank_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_tank_hited_Response.hited_tank_id)
}
inline ::int32_t Game_tank_hited_Response::_internal_hited_tank_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hited_tank_id_;
}
inline void Game_tank_hited_Response::_internal_set_hited_tank_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hited_tank_id_ = value;
}

// int32 health = 2;
inline void Game_tank_hited_Response::clear_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.health_ = 0;
}
inline ::int32_t Game_tank_hited_Response::health() const {
  // @@protoc_insertion_point(field_get:Message.Game_tank_hited_Response.health)
  return _internal_health();
}
inline void Game_tank_hited_Response::set_health(::int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:Message.Game_tank_hited_Response.health)
}
inline ::int32_t Game_tank_hited_Response::_internal_health() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.health_;
}
inline void Game_tank_hited_Response::_internal_set_health(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.health_ = value;
}

// -------------------------------------------------------------------

// Game_destroyed_tank_Response

// int32 destroyed_tank_id = 1;
inline void Game_destroyed_tank_Response::clear_destroyed_tank_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destroyed_tank_id_ = 0;
}
inline ::int32_t Game_destroyed_tank_Response::destroyed_tank_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_destroyed_tank_Response.destroyed_tank_id)
  return _internal_destroyed_tank_id();
}
inline void Game_destroyed_tank_Response::set_destroyed_tank_id(::int32_t value) {
  _internal_set_destroyed_tank_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_destroyed_tank_Response.destroyed_tank_id)
}
inline ::int32_t Game_destroyed_tank_Response::_internal_destroyed_tank_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destroyed_tank_id_;
}
inline void Game_destroyed_tank_Response::_internal_set_destroyed_tank_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.destroyed_tank_id_ = value;
}

// -------------------------------------------------------------------

// Game_getProp_Request

// int32 prop_id = 1;
inline void Game_getProp_Request::clear_prop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prop_id_ = 0;
}
inline ::int32_t Game_getProp_Request::prop_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_getProp_Request.prop_id)
  return _internal_prop_id();
}
inline void Game_getProp_Request::set_prop_id(::int32_t value) {
  _internal_set_prop_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_getProp_Request.prop_id)
}
inline ::int32_t Game_getProp_Request::_internal_prop_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prop_id_;
}
inline void Game_getProp_Request::_internal_set_prop_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prop_id_ = value;
}

// -------------------------------------------------------------------

// Game_prop_Response

// int32 prop_id = 1;
inline void Game_prop_Response::clear_prop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prop_id_ = 0;
}
inline ::int32_t Game_prop_Response::prop_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_prop_Response.prop_id)
  return _internal_prop_id();
}
inline void Game_prop_Response::set_prop_id(::int32_t value) {
  _internal_set_prop_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_prop_Response.prop_id)
}
inline ::int32_t Game_prop_Response::_internal_prop_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prop_id_;
}
inline void Game_prop_Response::_internal_set_prop_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prop_id_ = value;
}

// int32 tank_id = 2;
inline void Game_prop_Response::clear_tank_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tank_id_ = 0;
}
inline ::int32_t Game_prop_Response::tank_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_prop_Response.tank_id)
  return _internal_tank_id();
}
inline void Game_prop_Response::set_tank_id(::int32_t value) {
  _internal_set_tank_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_prop_Response.tank_id)
}
inline ::int32_t Game_prop_Response::_internal_tank_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tank_id_;
}
inline void Game_prop_Response::_internal_set_tank_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tank_id_ = value;
}

// -------------------------------------------------------------------

// UDP_INFO_REQ

// string ip = 1;
inline void UDP_INFO_REQ::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& UDP_INFO_REQ::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Message.UDP_INFO_REQ.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UDP_INFO_REQ::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Message.UDP_INFO_REQ.ip)
}
inline std::string* UDP_INFO_REQ::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:Message.UDP_INFO_REQ.ip)
  return _s;
}
inline const std::string& UDP_INFO_REQ::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void UDP_INFO_REQ::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* UDP_INFO_REQ::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* UDP_INFO_REQ::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Message.UDP_INFO_REQ.ip)
  return _impl_.ip_.Release();
}
inline void UDP_INFO_REQ::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.UDP_INFO_REQ.ip)
}

// int32 port = 2;
inline void UDP_INFO_REQ::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0;
}
inline ::int32_t UDP_INFO_REQ::port() const {
  // @@protoc_insertion_point(field_get:Message.UDP_INFO_REQ.port)
  return _internal_port();
}
inline void UDP_INFO_REQ::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Message.UDP_INFO_REQ.port)
}
inline ::int32_t UDP_INFO_REQ::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void UDP_INFO_REQ::_internal_set_port(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// -------------------------------------------------------------------

// UDP_INFO_RES

// bool OK = 1;
inline void UDP_INFO_RES::clear_ok() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ok_ = false;
}
inline bool UDP_INFO_RES::ok() const {
  // @@protoc_insertion_point(field_get:Message.UDP_INFO_RES.OK)
  return _internal_ok();
}
inline void UDP_INFO_RES::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:Message.UDP_INFO_RES.OK)
}
inline bool UDP_INFO_RES::_internal_ok() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ok_;
}
inline void UDP_INFO_RES::_internal_set_ok(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ok_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Message


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_myprotocol_2eproto_2epb_2eh
